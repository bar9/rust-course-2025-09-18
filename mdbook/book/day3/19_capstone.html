<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Final Integration - Complete Temperature Monitoring System</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-19-final-integration---complete-temperature-monitoring-system"><a class="header" href="#chapter-19-final-integration---complete-temperature-monitoring-system">Chapter 19: Final Integration - Complete Temperature Monitoring System</a></h1>
<h2 id="learning-objectives"><a class="header" href="#learning-objectives">Learning Objectives</a></h2>
<ul>
<li>Integrate all capstone increments into a working system</li>
<li>Deploy temperature monitoring to desktop and embedded targets</li>
<li>Test end-to-end system functionality</li>
<li>Analyze system performance and resource usage</li>
<li>Demonstrate production deployment considerations</li>
<li>Celebrate building a complete Rust system from scratch!</li>
</ul>
<h2 id="system-overview"><a class="header" href="#system-overview">System Overview</a></h2>
<p>Over Chapters 13-18, you've built a progressive temperature monitoring system. Now it's time to bring it all together into a complete, deployable solution.</p>
<h3 id="our-complete-architecture"><a class="header" href="#our-complete-architecture">Our Complete Architecture</a></h3>
<pre><code>┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   temp_core     │    │   temp_store    │    │   temp_async    │
│                 │    │                 │    │                 │
│ • Temperature   │───▶│ • Thread-safe   │───▶│ • Async monitor │
│ • Sensor traits│    │   storage       │    │ • Command loop  │
│ • Mock sensors  │    │ • Statistics    │    │ • Multi-sensor  │
│ • Testing       │    │ • Circular buf  │    │ • Error handling│
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│  temp_protocol  │    │ temp_embedded   │    │   temp_esp32    │
│                 │    │                 │    │                 │
│ • JSON &amp; binary │    │ • no_std impl   │    │ • ESP32-C3 code │
│ • Commands      │    │ • Fixed buffers │    │ • Hardware      │
│ • Serialization │    │ • Const config  │    │ • Deployment    │
│ • Protocol v1   │    │ • Embedded-ready│    │ • Production    │
└─────────────────┘    └─────────────────┘    └─────────────────┘
</code></pre>
<h3 id="what-weve-built"><a class="header" href="#what-weve-built">What We've Built</a></h3>
<ol>
<li><strong>temp_core</strong> (Chapter 13): Foundation types and traits with comprehensive testing</li>
<li><strong>temp_store</strong> (Chapter 14): Thread-safe storage with statistics and concurrent access</li>
<li><strong>temp_async</strong> (Chapter 15): Async monitoring system with tokio and command handling</li>
<li><strong>temp_protocol</strong> (Chapter 16): Binary and JSON protocols for efficient communication</li>
<li><strong>temp_embedded</strong> (Chapter 17): no_std version ready for embedded deployment</li>
<li><strong>temp_esp32</strong> (Chapter 18-19): Complete ESP32-C3 deployment target</li>
</ol>
<h2 id="integration-architecture"><a class="header" href="#integration-architecture">Integration Architecture</a></h2>
<p>Our system can run in multiple configurations:</p>
<h3 id="desktop-mode-full-features"><a class="header" href="#desktop-mode-full-features">Desktop Mode (Full Features)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Uses temp_async + temp_protocol + temp_store
// - Full std library
// - Network protocols
// - Web dashboard
// - Multiple sensors
// - Real-time monitoring
<span class="boring">}</span></code></pre></pre>
<h3 id="embedded-mode-resource-optimized"><a class="header" href="#embedded-mode-resource-optimized">Embedded Mode (Resource Optimized)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Uses temp_embedded + temp_core
// - no_std operation
// - Fixed-size buffers
// - Binary protocols only
// - Minimal memory footprint
// - Real-time guarantees
<span class="boring">}</span></code></pre></pre>
<h3 id="esp32-c3-mode-hardware-deployment"><a class="header" href="#esp32-c3-mode-hardware-deployment">ESP32-C3 Mode (Hardware Deployment)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Uses temp_esp32 (includes temp_embedded)
// - ESP-IDF integration
// - WiFi connectivity
// - Hardware sensors
// - OTA updates capability
// - Power management
<span class="boring">}</span></code></pre></pre>
<h2 id="desktop-integration-example"><a class="header" href="#desktop-integration-example">Desktop Integration Example</a></h2>
<p>Let's see how all pieces work together in a desktop application:</p>
<pre><pre class="playground"><code class="language-rust">// src/main.rs - Desktop temperature monitor
use std::time::Duration;
use tokio::time::sleep;
use temp_core::{Temperature, mock::MockTemperatureSensor, TemperatureSensor};
use temp_store::{TemperatureStore, TemperatureReading};
use temp_async::AsyncTemperatureMonitor;
use temp_protocol::{TemperatureProtocolHandler, Command, Response};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    println!("🌡️  Starting Temperature Monitoring System");

    // Initialize components from different chapters
    let mut sensor = MockTemperatureSensor::new("desktop_sensor".to_string(), 22.0);
    let store = TemperatureStore::new(1000);  // 1000 reading capacity
    let mut protocol_handler = TemperatureProtocolHandler::new();
    let mut async_monitor = AsyncTemperatureMonitor::new(100);

    println!("✅ All components initialized successfully");

    // Simulate system operation
    println!("\n🔄 Running system simulation...");

    // Chapter 13: Basic sensor reading
    println!("\n📊 Chapter 13 - Basic sensor reading:");
    let temp = sensor.read_temperature()?;
    println!("Temperature: {:.1}°C", temp.celsius);

    // Chapter 14: Thread-safe storage
    println!("\n💾 Chapter 14 - Thread-safe storage:");
    let reading = TemperatureReading::new(temp);
    store.add_reading(reading);
    println!("Stored reading, total count: {}", store.len());

    // Chapter 15: Async monitoring
    println!("\n⚡ Chapter 15 - Async monitoring:");
    let readings = simulate_async_readings().await;
    for reading in readings {
        store.add_reading(reading);
    }
    let stats = store.calculate_stats().unwrap();
    println!("Statistics - Min: {:.1}°C, Max: {:.1}°C, Avg: {:.1}°C",
             stats.min.celsius, stats.max.celsius, stats.average.celsius);

    // Chapter 16: Protocol communication
    println!("\n📡 Chapter 16 - Protocol communication:");
    let command = Command::GetStats { sensor_id: "desktop_sensor".to_string() };
    let request = protocol_handler.create_command(command);
    let response = protocol_handler.process_command(request);

    // Serialize to both formats
    let json_data = protocol_handler.serialize_json(&amp;response)?;
    let binary_data = protocol_handler.serialize_binary(&amp;response)?;
    println!("Protocol response - JSON: {} bytes, Binary: {} bytes",
             json_data.len(), binary_data.len());

    // Chapter 17: no_std comparison
    println!("\n🔧 Chapter 17 - Embedded comparison:");
    show_embedded_integration();

    // Chapter 18: Deployment ready
    println!("\n🚀 Chapter 18 - Deployment ready:");
    println!("✅ Desktop build: cargo build --release");
    println!("✅ Embedded build: cargo build -p temp_embedded --no-default-features");
    println!("✅ ESP32 build: cargo build -p temp_esp32 --target riscv32imc-esp-espidf");

    println!("\n🎉 Temperature monitoring system integration complete!");
    Ok(())
}

async fn simulate_async_readings() -&gt; Vec&lt;TemperatureReading&gt; {
    let mut readings = Vec::new();
    let mut sensor = MockTemperatureSensor::new("async_sensor".to_string(), 20.0);

    // Simulate 10 readings over time
    for i in 0..10 {
        sensor.set_temperature(20.0 + (i as f32) * 0.5);
        let temp = sensor.read_temperature().unwrap();
        let reading = TemperatureReading::new(temp);
        readings.push(reading);

        // Simulate time passing
        sleep(Duration::from_millis(100)).await;
    }

    readings
}

fn show_embedded_integration() {
    use temp_embedded::{EmbeddedTemperatureStore, EmbeddedProtocolHandler, READING_BUFFER_SIZE};

    // Show embedded version working
    let mut embedded_store: EmbeddedTemperatureStore&lt;READING_BUFFER_SIZE&gt; =
        EmbeddedTemperatureStore::new();
    let embedded_handler: EmbeddedProtocolHandler&lt;READING_BUFFER_SIZE&gt; =
        EmbeddedProtocolHandler::new();

    println!("  📱 Embedded store capacity: {} readings", embedded_store.capacity());
    println!("  💽 Memory usage: ~{} bytes",
             std::mem::size_of_val(&amp;embedded_store) +
             std::mem::size_of_val(&amp;embedded_handler));
    println!("  ⚡ Const configuration: Sample rate = {} Hz",
             temp_embedded::SAMPLE_RATE_HZ);
}</code></pre></pre>
<h2 id="embedded-integration-example"><a class="header" href="#embedded-integration-example">Embedded Integration Example</a></h2>
<p>Here's how the system works in embedded mode:</p>
<pre><pre class="playground"><code class="language-rust">// temp_esp32/src/main.rs - ESP32-C3 temperature monitor
#![no_std]
#![no_main]

use esp_backtrace as _;
use esp_hal::{
    clock::ClockControl,
    delay::Delay,
    gpio::{Io, Level, Output},
    peripherals::Peripherals,
    prelude::*,
    system::SystemControl,
};
use temp_embedded::{
    EmbeddedTemperatureStore, EmbeddedProtocolHandler,
    EmbeddedCommand, EmbeddedResponse, EmbeddedTemperatureReading,
    Temperature, READING_BUFFER_SIZE
};
use serde_json_core;

#[entry]
fn main() -&gt; ! {
    // ESP32-C3 initialization
    let peripherals = Peripherals::take();
    let system = SystemControl::new(peripherals.SYSTEM);
    let clocks = ClockControl::max(system.clock_control).freeze();
    let delay = Delay::new(&amp;clocks);

    // Initialize GPIO for status LED
    let io = Io::new(peripherals.GPIO, peripherals.IO_MUX);
    let mut led = Output::new(io.pins.gpio8, Level::Low);

    // Initialize our temperature monitoring components
    let mut store: EmbeddedTemperatureStore&lt;READING_BUFFER_SIZE&gt; =
        EmbeddedTemperatureStore::new();
    let mut protocol_handler: EmbeddedProtocolHandler&lt;READING_BUFFER_SIZE&gt; =
        EmbeddedProtocolHandler::new();

    // Initialize with boot time
    protocol_handler.init(get_boot_timestamp());

    // System status
    esp_println::println!("🌡️ ESP32-C3 Temperature Monitor Starting");
    esp_println::println!("📊 Buffer capacity: {} readings", store.capacity());
    esp_println::println!("⚡ Sample rate: {} Hz", temp_embedded::SAMPLE_RATE_HZ);
    esp_println::println!("📋 JSON output format: STATUS_JSON, STATS_JSON, READING_JSON");
    esp_println::println!("🔧 Send JSON commands: {{\"GetStatus\"}}, {{\"GetStats\"}}, {{\"GetLatestReading\"}}");

    // Demonstrate serde JSON functionality
    esp_println::println!("=== SERDE DEMO: Processing sample commands ===");
    demonstrate_json_commands(&amp;mut protocol_handler, 0);
    esp_println::println!("=== Starting continuous monitoring ===");

    let mut reading_count = 0u32;

    loop {
        // Flash LED to show we're alive
        led.set_high();
        delay.delay_millis(50);
        led.set_low();

        // Simulate reading from hardware sensor
        let adc_value = simulate_adc_reading(reading_count);
        let temperature = Temperature::from_embedded_sensor(adc_value);

        // Store the reading
        let timestamp = get_current_timestamp();
        if let Err(e) = protocol_handler.add_reading(temperature, timestamp) {
            esp_println::println!("Storage error: {}", e);
        } else {
            reading_count += 1;

            if reading_count % 10 == 0 {
                // Process status command and output as JSON
                let status_command = EmbeddedCommand::GetStatus;
                let response = protocol_handler.process_command(status_command, timestamp);

                // Serialize status response to JSON using serde
                if let Ok(json_str) = serde_json_core::to_string::&lt;_, 256&gt;(&amp;response) {
                    esp_println::println!("STATUS_JSON: {}", json_str);
                }

                // Show latest statistics as JSON
                let stats_command = EmbeddedCommand::GetStats;
                let stats_response = protocol_handler.process_command(stats_command, timestamp);

                if let Ok(json_str) = serde_json_core::to_string::&lt;_, 256&gt;(&amp;stats_response) {
                    esp_println::println!("STATS_JSON: {}", json_str);
                }

                // Output current temperature reading as JSON
                let current_reading = EmbeddedTemperatureReading::new(temperature, timestamp);
                if let Ok(json_str) = serde_json_core::to_string::&lt;_, 256&gt;(&amp;current_reading) {
                    esp_println::println!("READING_JSON: {}", json_str);
                }
            }
        }

        // Wait according to sample rate (100ms for 10Hz)
        delay.delay_millis(100);
    }
}

fn demonstrate_json_commands(protocol_handler: &amp;mut EmbeddedProtocolHandler&lt;READING_BUFFER_SIZE&gt;, timestamp: u32) {
    esp_println::println!("📝 Demonstrating JSON command processing with serde:");

    // Add some sample readings first
    let temp1 = Temperature::from_embedded_sensor(simulate_adc_reading(0));
    let temp2 = Temperature::from_embedded_sensor(simulate_adc_reading(10));
    let temp3 = Temperature::from_embedded_sensor(simulate_adc_reading(20));

    let _ = protocol_handler.add_reading(temp1, timestamp);
    let _ = protocol_handler.add_reading(temp2, timestamp + 1);
    let _ = protocol_handler.add_reading(temp3, timestamp + 2);

    // Demonstrate various commands
    let commands = [
        ("GetStatus", EmbeddedCommand::GetStatus),
        ("GetStats", EmbeddedCommand::GetStats),
        ("GetLatestReading", EmbeddedCommand::GetLatestReading),
        ("GetReadingCount", EmbeddedCommand::GetReadingCount)
    ];

    for (cmd_name, command) in &amp;commands {
        esp_println::println!("🔄 Processing command: {}", cmd_name);

        // Process the command
        let response = protocol_handler.process_command(command.clone(), timestamp + 10);

        // Serialize response to JSON using serde
        match serde_json_core::to_string::&lt;_, 512&gt;(&amp;response) {
            Ok(json_response) =&gt; {
                esp_println::println!("✅ JSON Response: {}", json_response);
            }
            Err(_) =&gt; {
                esp_println::println!("❌ Failed to serialize response");
            }
        }
        esp_println::println!("");
    }
}

fn simulate_adc_reading(count: u32) -&gt; u16 {
    // Simulate temperature sensor ADC reading
    // Varies between ~20-30°C (ADC values ~800-1200 for our conversion)
    let base_temp = 25.0;
    let variation = (count as f32 * 0.1).sin() * 5.0;
    let temp_celsius = base_temp + variation;

    // Convert to 12-bit ADC value (assuming 10mV/°C sensor, 3.3V ref)
    let voltage = temp_celsius * 0.01; // 10mV/°C
    let adc_value = (voltage / 3.3) * 4095.0;
    adc_value as u16
}

fn get_boot_timestamp() -&gt; u32 {
    // In real implementation, this would be actual boot time
    0
}

fn get_current_timestamp() -&gt; u32 {
    // In real implementation, this would use hardware timer
    // For simulation, we'll use a simple counter
    static mut COUNTER: u32 = 0;
    unsafe {
        COUNTER += 1;
        COUNTER
    }
}</code></pre></pre>
<h2 id="testing-the-complete-system"><a class="header" href="#testing-the-complete-system">Testing the Complete System</a></h2>
<h3 id="end-to-end-test-scenarios"><a class="header" href="#end-to-end-test-scenarios">End-to-End Test Scenarios</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// tests/integration_tests.rs
use temp_core::{Temperature, mock::MockTemperatureSensor, TemperatureSensor};
use temp_store::{TemperatureStore, TemperatureReading};
use temp_protocol::{TemperatureProtocolHandler, Command, Response};
use temp_embedded::{EmbeddedTemperatureStore, EmbeddedProtocolHandler};

#[tokio::test]
async fn test_complete_system_integration() {
    // Test that all components work together
    let mut sensor = MockTemperatureSensor::new("integration_test".to_string(), 25.0);
    let store = TemperatureStore::new(100);
    let mut protocol_handler = TemperatureProtocolHandler::new();

    // 1. Read sensor data
    let temp = sensor.read_temperature().unwrap();
    assert!((temp.celsius - 25.0).abs() &lt; 1.0);

    // 2. Store readings
    let reading = TemperatureReading::new(temp);
    store.add_reading(reading);
    assert_eq!(store.len(), 1);

    // 3. Process protocol commands
    let command = Command::GetReading { sensor_id: "integration_test".to_string() };
    let request = protocol_handler.create_command(command);
    let response = protocol_handler.process_command(request);

    // Verify response
    if let temp_protocol::MessagePayload::Response(Response::Reading { temperature, .. }) = response.payload {
        assert!((temperature - 25.0).abs() &lt; 1.0);
    } else {
        panic!("Expected reading response");
    }

    println!("✅ Complete system integration test passed");
}

#[test]
fn test_desktop_vs_embedded_compatibility() {
    // Test that both implementations produce compatible results
    use temp_embedded::EmbeddedTemperatureReading;

    let temp = Temperature::new(23.5);

    // Desktop version
    let desktop_reading = TemperatureReading::new(temp);

    // Embedded version
    let embedded_reading = EmbeddedTemperatureReading::new(temp, 1000);

    // Both should have same temperature
    assert_eq!(desktop_reading.temperature, embedded_reading.temperature);

    println!("✅ Desktop/Embedded compatibility test passed");
}

#[test]
fn test_protocol_binary_size_optimization() {
    use temp_protocol::TemperatureProtocolHandler;
    use temp_embedded::EmbeddedProtocolHandler;

    let desktop_handler = TemperatureProtocolHandler::new();
    let embedded_handler: EmbeddedProtocolHandler&lt;64&gt; = EmbeddedProtocolHandler::new();

    // Create same command in both systems
    let command = temp_protocol::Command::GetStatus;
    let embedded_command = temp_embedded::EmbeddedCommand::GetStatus;

    // Test serialization sizes
    let desktop_msg = desktop_handler.create_command(command);
    let desktop_json = desktop_handler.serialize_json(&amp;desktop_msg).unwrap();
    let desktop_binary = desktop_handler.serialize_binary(&amp;desktop_msg).unwrap();

    let embedded_binary = embedded_handler.serialize_binary(&amp;embedded_command).unwrap();

    println!("Desktop JSON: {} bytes", desktop_json.len());
    println!("Desktop binary: {} bytes", desktop_binary.len());
    println!("Embedded binary: {} bytes", embedded_binary.len());

    // Binary should be smaller than JSON
    assert!(desktop_binary.len() &lt; desktop_json.len());

    // Embedded should be very compact
    assert!(embedded_binary.len() &lt;= desktop_binary.len());

    println!("✅ Protocol size optimization test passed");
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-analysis"><a class="header" href="#performance-analysis">Performance Analysis</a></h2>
<h3 id="memory-usage-comparison"><a class="header" href="#memory-usage-comparison">Memory Usage Comparison</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Analysis of memory usage across different modes
fn analyze_memory_usage() {
    use std::mem::size_of;
    use temp_store::TemperatureStore;
    use temp_embedded::{EmbeddedTemperatureStore, EmbeddedProtocolHandler};
    use temp_protocol::TemperatureProtocolHandler;

    println!("\n📊 Memory Usage Analysis");
    println!("========================");

    // Desktop components
    println!("\n🖥️  Desktop Mode:");
    println!("  TemperatureStore:           ~{} bytes + Vec capacity",
             size_of::&lt;TemperatureStore&gt;());
    println!("  ProtocolHandler:            ~{} bytes + HashMap capacity",
             size_of::&lt;TemperatureProtocolHandler&gt;());
    println!("  Total baseline:             ~{} bytes (+ dynamic allocations)",
             size_of::&lt;TemperatureStore&gt;() + size_of::&lt;TemperatureProtocolHandler&gt;());

    // Embedded components
    println!("\n📱 Embedded Mode (64 readings):");
    let embedded_store: EmbeddedTemperatureStore&lt;64&gt; = EmbeddedTemperatureStore::new();
    let embedded_handler: EmbeddedProtocolHandler&lt;64&gt; = EmbeddedProtocolHandler::new();

    println!("  EmbeddedTemperatureStore:   {} bytes", size_of_val(&amp;embedded_store));
    println!("  EmbeddedProtocolHandler:    {} bytes", size_of_val(&amp;embedded_handler));
    println!("  Total fixed:                {} bytes (no heap allocations)",
             size_of_val(&amp;embedded_store) + size_of_val(&amp;embedded_handler));

    // Performance characteristics
    println!("\n⚡ Performance Characteristics:");
    println!("  Desktop:  Dynamic allocation, thread-safe, unlimited capacity");
    println!("  Embedded: Fixed allocation, deterministic, limited capacity");
    println!("  ESP32-C3: ~320KB RAM available, ~2MB flash for code");
}
<span class="boring">}</span></code></pre></pre>
<h3 id="response-time-benchmarks"><a class="header" href="#response-time-benchmarks">Response Time Benchmarks</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Benchmark different operations
use std::time::{Duration, Instant};

fn benchmark_operations() {
    println!("\n🏁 Performance Benchmarks");
    println!("=========================");

    // Sensor reading benchmark
    let mut sensor = temp_core::mock::MockTemperatureSensor::new("benchmark".to_string(), 25.0);
    let start = Instant::now();
    for _ in 0..10_000 {
        let _ = sensor.read_temperature().unwrap();
    }
    let sensor_time = start.elapsed();
    println!("Sensor readings:     {} ns per reading",
             sensor_time.as_nanos() / 10_000);

    // Storage benchmark
    let store = temp_store::TemperatureStore::new(10_000);
    let temp = temp_core::Temperature::new(25.0);
    let reading = temp_store::TemperatureReading::new(temp);

    let start = Instant::now();
    for _ in 0..10_000 {
        store.add_reading(reading);
    }
    let storage_time = start.elapsed();
    println!("Storage operations:  {} ns per operation",
             storage_time.as_nanos() / 10_000);

    // Protocol serialization benchmark
    let mut handler = temp_protocol::TemperatureProtocolHandler::new();
    let command = temp_protocol::Command::GetStatus;
    let message = handler.create_command(command);

    let start = Instant::now();
    for _ in 0..1_000 {
        let _ = handler.serialize_binary(&amp;message).unwrap();
    }
    let serialize_time = start.elapsed();
    println!("Binary serialization: {} μs per message",
             serialize_time.as_micros() / 1_000);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="production-deployment-considerations"><a class="header" href="#production-deployment-considerations">Production Deployment Considerations</a></h2>
<h3 id="what-weve-achieved"><a class="header" href="#what-weve-achieved">What We've Achieved</a></h3>
<p>✅ <strong>Memory Safety</strong>: No buffer overflows, dangling pointers, or memory leaks
✅ <strong>Concurrency</strong>: Thread-safe operations without data races
✅ <strong>Performance</strong>: Zero-cost abstractions, optimized for embedded
✅ <strong>Reliability</strong>: Comprehensive error handling and recovery
✅ <strong>Testability</strong>: Extensive test coverage across all components
✅ <strong>Portability</strong>: Runs on desktop, embedded, and ESP32-C3
✅ <strong>Maintainability</strong>: Clean architecture with separation of concerns</p>
<h3 id="production-enhancements-needed"><a class="header" href="#production-enhancements-needed">Production Enhancements Needed</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Additional features for production deployment
pub struct ProductionEnhancements {
    // Security
    pub authentication: bool,        // User authentication
    pub encryption: bool,           // Data encryption at rest/transit
    pub secure_boot: bool,          // Verified boot process

    // Reliability
    pub watchdog: bool,             // Hardware watchdog timer
    pub error_recovery: bool,       // Automatic error recovery
    pub redundancy: bool,           // Sensor redundancy

    // Connectivity
    pub wifi_management: bool,      // WiFi connection management
    pub ota_updates: bool,          // Over-the-air firmware updates
    pub cloud_integration: bool,    // Cloud data upload

    // Monitoring
    pub remote_diagnostics: bool,   // Remote system monitoring
    pub performance_metrics: bool,  // Performance telemetry
    pub alerting: bool,            // Automated alerts

    // Standards Compliance
    pub industrial_protocols: bool, // Modbus, OPC-UA, etc.
    pub safety_standards: bool,     // IEC 61508, ISO 26262
    pub regulatory: bool,          // FCC, CE, UL certification
}
<span class="boring">}</span></code></pre></pre>
<h3 id="deployment-architecture-options"><a class="header" href="#deployment-architecture-options">Deployment Architecture Options</a></h3>
<pre><code>1. Standalone Embedded Device
   ┌─────────────────┐
   │    ESP32-C3     │
   │                 │
   │  temp_embedded  │
   │  WiFi/Bluetooth │
   │  Local Display  │
   └─────────────────┘

2. Gateway + Cloud Architecture
   ┌─────────────┐    ┌─────────────┐    ┌─────────────┐
   │ ESP32-C3    │───▶│  Gateway    │───▶│   Cloud     │
   │ Sensors     │    │  Raspberry  │    │  Dashboard  │
   │ temp_esp32  │    │  Pi/PC      │    │  Analytics  │
   └─────────────┘    └─────────────┘    └─────────────┘

3. Industrial IoT Platform
   ┌─────────────┐    ┌─────────────┐    ┌─────────────┐
   │ Multiple    │───▶│  Industrial │───▶│  SCADA      │
   │ ESP32-C3    │    │  Gateway    │    │  System     │
   │ Nodes       │    │  Modbus/OPC │    │  HMI        │
   └─────────────┘    └─────────────┘    └─────────────┘
</code></pre>
<h2 id="exercise-deploy-your-complete-temperature-monitor"><a class="header" href="#exercise-deploy-your-complete-temperature-monitor">Exercise: Deploy Your Complete Temperature Monitor</a></h2>
<p>Time to bring everything together! You'll deploy and test your complete temperature monitoring system.</p>
<h3 id="requirements"><a class="header" href="#requirements">Requirements</a></h3>
<p>Deploy your system in at least one configuration:</p>
<ol>
<li><strong>Desktop Configuration</strong>: Full-featured system with all capabilities</li>
<li><strong>Embedded Simulation</strong>: Resource-constrained version for testing</li>
<li><strong>ESP32-C3 Deployment</strong> (if hardware available): Real hardware deployment</li>
</ol>
<h3 id="implementation-steps"><a class="header" href="#implementation-steps">Implementation Steps</a></h3>
<ol>
<li>
<p><strong>System Integration</strong>:</p>
<pre><code class="language-bash"># Test all components work together
cargo test --workspace

# Build desktop version
cargo build --release --workspace

# Build embedded version
cargo build -p temp_embedded --no-default-features --release
</code></pre>
</li>
<li>
<p><strong>Desktop Deployment</strong>:</p>
<pre><code class="language-bash"># Run integrated desktop system
cargo run --example desktop_integration

# Test with multiple sensor types
cargo run --example multi_sensor_demo
</code></pre>
</li>
<li>
<p><strong>Embedded Testing</strong>:</p>
<pre><code class="language-bash"># Test embedded components
cargo test -p temp_embedded

# Check binary size
cargo size -p temp_embedded --release
</code></pre>
</li>
<li>
<p><strong>ESP32-C3 Hardware Deployment</strong>:</p>
<p><strong>Prerequisites</strong>:</p>
<ul>
<li>ESP32-C3 development board</li>
<li>USB-C cable for programming and power</li>
<li>probe-rs installed: <code>cargo install probe-rs --features cli</code></li>
<li>Any Serial USB Terminal app (like "Serial USB Terminal" on macOS, PuTTY, screen, etc.)</li>
</ul>
<p><strong>Hardware Setup</strong>:
The ESP32-C3 includes an internal temperature sensor, so no external components are required for this demo.</p>
<p><strong>Build and Flash</strong>:</p>
<pre><code class="language-bash"># Navigate to ESP32 project
cd day3_capstone/temp_esp32

# Build for ESP32-C3 hardware (default feature)
cargo build --release

# Flash with probe-rs (working command)
probe-rs run --chip=esp32c3 target/riscv32imc-unknown-none-elf/release/temp_esp32

# Alternative: Flash with espflash
# espflash flash --monitor target/riscv32imc-unknown-none-elf/release/temp_esp32
</code></pre>
<p><strong>Serial Monitoring</strong>:
The ESP32 now outputs via USB Serial (not RTT), making it compatible with any standard Serial USB Terminal app:</p>
<pre><code class="language-bash"># Using screen (macOS/Linux)
screen /dev/cu.usbmodem* 115200

# Using Serial USB Terminal app
# - Connect to the ESP32-C3 device
# - Set baud rate to 115200
# - You'll see JSON output with serde serialization examples
</code></pre>
<p><strong>Expected Output</strong>:
The ESP32 now demonstrates serde serialization in embedded contexts:</p>
<pre><code>🌡️ ESP32-C3 Temperature Monitor Starting
📊 Buffer capacity: 64 readings
⚡ Sample rate: 10 Hz
📋 JSON output format: STATUS_JSON, STATS_JSON, READING_JSON
🔧 Send JSON commands: {"GetStatus"}, {"GetStats"}, {"GetLatestReading"}
=== SERDE DEMO: Processing sample commands ===
🔄 Processing command: GetStatus
✅ JSON Response: {"Status":{"uptime_seconds":0,"reading_count":3,"sample_rate":10,"buffer_usage":4}}
🔄 Processing command: GetStats
✅ JSON Response: {"Stats":{"min":{"celsius":25.0},"max":{"celsius":25.0},"average":{"celsius":25.0},"count":3}}
=== Starting continuous monitoring ===
STATUS_JSON: {"Status":{"uptime_seconds":1,"reading_count":10,"sample_rate":10,"buffer_usage":15}}
STATS_JSON: {"Stats":{"min":{"celsius":22.0},"max":{"celsius":27.5},"average":{"celsius":24.8},"count":10}}
READING_JSON: {"temperature":{"celsius":25.2},"timestamp":1001}
</code></pre>
<p><strong>Key Features Demonstrated</strong>:</p>
<ul>
<li><strong>Serde in no_std</strong>: JSON serialization works in embedded environments using <code>serde-json-core</code></li>
<li><strong>Serial USB compatibility</strong>: Replaced RTT with USB Serial for universal terminal support</li>
<li><strong>Educational value</strong>: Students see practical serde usage in embedded contexts</li>
<li><strong>Structured output</strong>: JSON format makes data easily parseable by IoT systems and APIs</li>
</ul>
<h3 id="understanding-the-serial-usb-terminal-integration"><a class="header" href="#understanding-the-serial-usb-terminal-integration">Understanding the Serial USB Terminal Integration</a></h3>
<p>The ESP32 implementation now includes several improvements for better accessibility:</p>
<p><strong>1. USB Serial vs RTT (Real-Time Transfer)</strong>:</p>
<ul>
<li><strong>Previous</strong>: Used RTT which requires special debugging tools like probe-rs or J-Link</li>
<li><strong>Current</strong>: Uses standard USB Serial that works with any serial terminal app</li>
<li><strong>Benefit</strong>: More accessible for students and production IoT applications</li>
</ul>
<p><strong>2. Serde Integration in Embedded</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Shows how serde works in no_std environments
use serde_json_core;  // no_std compatible JSON library

// All embedded types now support serialization:
#[derive(Serialize, Deserialize)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct EmbeddedTemperatureReading {
    pub temperature: Temperature,
    pub timestamp: u32,
}

// JSON serialization in no_std:
if let Ok(json_str) = serde_json_core::to_string::&lt;_, 256&gt;(&amp;response) {
    esp_println!("STATUS_JSON: {}", json_str);
}
<span class="boring">}</span></code></pre></pre>
<p><strong>3. JSON Output Format</strong>:
The system outputs structured JSON with prefixes for easy parsing:</p>
<ul>
<li><code>STATUS_JSON:</code> - System status and health information</li>
<li><code>STATS_JSON:</code> - Temperature statistics (min, max, average)</li>
<li><code>READING_JSON:</code> - Individual temperature readings with timestamps</li>
</ul>
<p><strong>4. Serial Terminal Setup</strong>:</p>
<pre><code class="language-bash"># Different ways to connect to the ESP32:

# Option 1: Using screen (built-in on macOS/Linux)
screen /dev/cu.usbmodem* 115200
# Press Ctrl+A, then K to exit

# Option 2: Using minicom (Linux)
minicom -b 115200 -D /dev/ttyUSB0

# Option 3: Serial USB Terminal app (GUI - recommended for beginners)
# - Download from Mac App Store or similar
# - Connect to ESP32-C3 device
# - Set baud rate: 115200
# - Data bits: 8, Parity: None, Stop bits: 1
</code></pre>
<p><strong>5. JSON Parsing Examples</strong>:
The JSON output can be easily parsed by other systems:</p>
<pre><code class="language-python"># Python example for parsing ESP32 output
import json
import serial

ser = serial.Serial('/dev/cu.usbmodem*', 115200)

while True:
    line = ser.readline().decode('utf-8').strip()
    if line.startswith('STATUS_JSON:'):
        json_data = line[12:]  # Remove prefix
        status = json.loads(json_data)
        print(f"Uptime: {status['Status']['uptime_seconds']}s")
        print(f"Readings: {status['Status']['reading_count']}")
    elif line.startswith('READING_JSON:'):
        json_data = line[13:]  # Remove prefix
        reading = json.loads(json_data)
        print(f"Temperature: {reading['temperature']['celsius']}°C")
</code></pre>
<p><strong>Testing Different Modes</strong>:</p>
<pre><code class="language-bash"># Run in simulation mode (for testing without hardware)
cargo run --no-default-features --features simulation --target aarch64-apple-darwin

# Run hardware mode (default - for actual ESP32-C3)
cargo build --release
probe-rs run --chip=esp32c3 target/riscv32imc-unknown-none-elf/release/temp_esp32
</code></pre>
<p><strong>Troubleshooting Tips</strong>:</p>
<ul>
<li><strong>Simulation mode</strong>: Requires <code>--target</code> flag to avoid embedded target compilation</li>
<li><strong>Hardware vs Simulation features</strong>: Use <code>--no-default-features --features simulation</code> for desktop testing</li>
<li><strong>Serial monitoring</strong>: Connect at 115200 baud to see JSON-formatted output</li>
<li><strong>Build errors</strong>: Make sure <code>probe-rs</code> is installed with CLI features: <code>cargo install probe-rs --features cli</code></li>
</ul>
</li>
</ol>
<h3 id="success-criteria"><a class="header" href="#success-criteria">Success Criteria</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
All workspace tests pass (31+ tests across all crates)</li>
<li><input disabled="" type="checkbox"/>
Desktop integration runs without errors</li>
<li><input disabled="" type="checkbox"/>
Embedded version compiles with size constraints</li>
<li><input disabled="" type="checkbox"/>
System demonstrates all functionality from Chapters 13-18:
<ul>
<li><input disabled="" type="checkbox"/>
Temperature sensor reading (Chapter 13)</li>
<li><input disabled="" type="checkbox"/>
Thread-safe storage (Chapter 14)</li>
<li><input disabled="" type="checkbox"/>
Async monitoring (Chapter 15)</li>
<li><input disabled="" type="checkbox"/>
JSON and binary protocol communication (Chapter 16)</li>
<li><input disabled="" type="checkbox"/>
no_std operation with serde support (Chapter 17)</li>
<li><input disabled="" type="checkbox"/>
Multi-target building and ESP32 deployment (Chapter 18)</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
ESP32-C3 deployment specific requirements:
<ul>
<li><input disabled="" type="checkbox"/>
Successful flash with: <code>probe-rs run --chip=esp32c3 target/riscv32imc-unknown-none-elf/release/temp_esp32</code></li>
<li><input disabled="" type="checkbox"/>
Serial USB Terminal connectivity at 115200 baud</li>
<li><input disabled="" type="checkbox"/>
JSON output demonstrates serde in no_std environment</li>
<li><input disabled="" type="checkbox"/>
Structured data output (STATUS_JSON, STATS_JSON, READING_JSON format)</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
Performance analysis shows reasonable resource usage</li>
<li><input disabled="" type="checkbox"/>
System runs continuously without crashes</li>
</ul>
<h3 id="validation-tests"><a class="header" href="#validation-tests">Validation Tests</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Run these tests to validate your complete system
#[tokio::test]
async fn test_my_complete_temperature_monitor() {
    // TODO: Create a comprehensive test that:
    // 1. Initializes all components
    // 2. Simulates sensor readings over time
    // 3. Tests protocol communication
    // 4. Verifies data storage and statistics
    // 5. Confirms error handling works
    // 6. Measures performance characteristics

    println!("🎉 My temperature monitor works!");
}
<span class="boring">}</span></code></pre></pre>
<h2 id="congratulations"><a class="header" href="#congratulations">Congratulations!</a></h2>
<p>You've successfully built a complete, production-ready temperature monitoring system in Rust!</p>
<h3 id="what-youve-accomplished"><a class="header" href="#what-youve-accomplished">What You've Accomplished</a></h3>
<p>🌟 <strong>Technical Mastery</strong>: You've applied every major Rust concept:</p>
<ul>
<li>Ownership and borrowing for memory safety</li>
<li>Error handling with Result and Option</li>
<li>Trait-based abstraction and generics</li>
<li>Concurrent programming with threads and async</li>
<li>no_std embedded programming</li>
<li>Comprehensive testing strategies</li>
<li>Production build and deployment</li>
</ul>
<p>🌟 <strong>System Engineering</strong>: You've built a real system:</p>
<ul>
<li>Modular architecture with clean interfaces</li>
<li>Progressive complexity from simple to embedded</li>
<li>Multiple deployment targets from one codebase</li>
<li>Comprehensive testing and validation</li>
<li>Production deployment considerations</li>
</ul>
<p>🌟 <strong>Professional Skills</strong>: You've demonstrated:</p>
<ul>
<li>Code organization and workspace management</li>
<li>CI/CD pipeline setup and automation</li>
<li>Cross-compilation and target optimization</li>
<li>Documentation and API design</li>
<li>Performance analysis and optimization</li>
</ul>
<h3 id="your-journey"><a class="header" href="#your-journey">Your Journey</a></h3>
<ul>
<li><strong>Day 1</strong>: Rust fundamentals, ownership, and basic types</li>
<li><strong>Day 2</strong>: Advanced features, traits, error handling, and async</li>
<li><strong>Day 3</strong>: Applied everything to build a complete embedded system</li>
</ul>
<p>You started with <code>println!("Hello, world!");</code> and finished with a deployable embedded temperature monitoring system. That's an incredible journey!</p>
<h3 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h3>
<p>Your Rust journey continues:</p>
<ol>
<li><strong>Extend Your System</strong>: Add features like WiFi connectivity, web dashboards, or cloud integration</li>
<li><strong>Contribute to Open Source</strong>: Your skills are now ready for contributing to Rust projects</li>
<li><strong>Build More Systems</strong>: Apply these patterns to other embedded or systems programming projects</li>
<li><strong>Share Your Knowledge</strong>: Help others learn Rust and embedded programming</li>
</ol>
<h3 id="final-thoughts"><a class="header" href="#final-thoughts">Final Thoughts</a></h3>
<p>Rust empowers you to build systems that are:</p>
<ul>
<li><strong>Safe</strong>: Memory safety without garbage collection</li>
<li><strong>Fast</strong>: Zero-cost abstractions and predictable performance</li>
<li><strong>Reliable</strong>: Comprehensive error handling and testing</li>
<li><strong>Maintainable</strong>: Clean abstractions and excellent tooling</li>
<li><strong>Portable</strong>: Write once, deploy everywhere</li>
</ul>
<p>You now have the skills to build the safe, fast, and reliable systems that power our digital world.</p>
<p><strong>Welcome to the Rust community! 🦀</strong></p>
<hr />
<p><em>"The best way to learn systems programming is to build systems. You've just built a great one!"</em></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../day3/18_build_deploy.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../transfer/22_iterators.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../day3/18_build_deploy.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../transfer/22_iterators.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
