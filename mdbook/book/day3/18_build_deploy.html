<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Build, Package &amp; Deploy</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-18-build-package--deploy"><a class="header" href="#chapter-18-build-package--deploy">Chapter 18: Build, Package &amp; Deploy</a></h1>
<h2 id="learning-objectives"><a class="header" href="#learning-objectives">Learning Objectives</a></h2>
<ul>
<li>Master Cargo workspaces for multi-crate embedded projects</li>
<li>Use features for std/no_std conditional compilation</li>
<li>Set up cross-compilation for embedded targets (ESP32-C3)</li>
<li>Implement CI/CD pipelines for embedded systems</li>
<li>Optimize binary size for resource-constrained environments</li>
<li>Deploy to embedded hardware using modern tooling</li>
</ul>
<h2 id="cargo-workspaces-for-embedded-projects"><a class="header" href="#cargo-workspaces-for-embedded-projects">Cargo Workspaces for Embedded Projects</a></h2>
<p>Our temperature monitoring system demonstrates how workspaces manage complexity in embedded projects with multiple targets.</p>
<h3 id="our-capstone-workspace-structure"><a class="header" href="#our-capstone-workspace-structure">Our Capstone Workspace Structure</a></h3>
<pre><code class="language-toml"># Cargo.toml (workspace root)
[workspace]
members = [
    "temp_core",      # Core types and traits
    "temp_store",     # Thread-safe storage
    "temp_async",     # Async monitoring
    "temp_protocol",  # Serialization protocols
    "temp_embedded",  # no_std embedded version
    "temp_esp32",     # ESP32-C3 deployment
]
resolver = "2"

# Shared dependencies across all crates
[workspace.dependencies]
serde = { version = "1.0", features = ["derive"] }
tokio = { version = "1.35", features = ["full"] }
heapless = "0.8"
postcard = { version = "1.0", features = ["alloc"] }

# Optimized release profile
[profile.release]
lto = true              # Link-time optimization
opt-level = 3           # Maximum optimization
codegen-units = 1       # Better optimization

# Embedded-specific profile
[profile.embedded]
inherits = "release"
opt-level = "z"         # Optimize for size
strip = true            # Strip debug symbols
panic = "abort"         # Smaller panic handler
</code></pre>
<p>This structure allows us to:</p>
<ul>
<li><strong>Shared Development</strong>: All crates use the same dependency versions</li>
<li><strong>Progressive Complexity</strong>: Each crate builds on the previous ones</li>
<li><strong>Multi-Target Builds</strong>: Desktop and embedded from the same codebase</li>
<li><strong>Optimized Profiles</strong>: Different optimization strategies for different use cases</li>
</ul>
<h3 id="member-crate-configuration"><a class="header" href="#member-crate-configuration">Member Crate Configuration</a></h3>
<pre><code class="language-toml"># temp_core/Cargo.toml - Foundation crate
[package]
name = "temp_core"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = { workspace = true, default-features = false, optional = true }

[features]
default = ["serde"]
serde = ["dep:serde"]
std = []
</code></pre>
<pre><code class="language-toml"># temp_embedded/Cargo.toml - no_std version
[package]
name = "temp_embedded"
version = "0.1.0"
edition = "2021"

[dependencies]
heapless = { workspace = true }
serde = { workspace = true, default-features = false }
postcard = { workspace = true }
temp_core = { path = "../temp_core", default-features = false }

[features]
default = []
std = ["temp_core/std"]
</code></pre>
<h3 id="workspace-commands-for-our-project"><a class="header" href="#workspace-commands-for-our-project">Workspace Commands for Our Project</a></h3>
<pre><code class="language-bash"># Build all crates for desktop
cargo build --workspace

# Test specific embedded crate
cargo test -p temp_embedded

# Build only the embedded components
cargo build -p temp_embedded -p temp_esp32

# Check all crates for both std and no_std
cargo check --workspace --all-targets
cargo check --workspace --no-default-features

# Run desktop version of temperature monitor
cargo run -p temp_protocol
</code></pre>
<h2 id="features-for-stdno_std-conditional-compilation"><a class="header" href="#features-for-stdno_std-conditional-compilation">Features for std/no_std Conditional Compilation</a></h2>
<p>Features enable the same codebase to work on both desktop and embedded systems.</p>
<h3 id="feature-strategy-in-our-temperature-monitor"><a class="header" href="#feature-strategy-in-our-temperature-monitor">Feature Strategy in Our Temperature Monitor</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// temp_core/src/lib.rs
#![cfg_attr(not(feature = "std"), no_std)]

// Conditional imports based on environment
#[cfg(feature = "std")]
use std::fmt;

#[cfg(not(feature = "std"))]
use core::fmt;

#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};

// Conditional derive based on features
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Temperature {
    pub celsius: f32,
}

// Platform-specific implementations
impl Temperature {
    #[cfg(feature = "std")]
    pub fn from_system_sensor() -&gt; Result&lt;Self, std::io::Error&gt; {
        // Read from system temperature sensor
        unimplemented!("System sensor reading")
    }

    #[cfg(not(feature = "std"))]
    pub fn from_embedded_sensor(adc_value: u16) -&gt; Self {
        // Convert ADC reading to temperature
        let voltage = (adc_value as f32 / 4095.0) * 3.3;
        let celsius = voltage / 0.01; // 10mV/°C sensor
        Temperature { celsius }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="conditional-storage-implementation"><a class="header" href="#conditional-storage-implementation">Conditional Storage Implementation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// temp_store/src/lib.rs
#[cfg(feature = "std")]
use std::sync::{Arc, Mutex};

#[cfg(not(feature = "std"))]
use heapless::Vec;

// Different storage backends based on environment
#[cfg(feature = "std")]
pub struct TemperatureStore {
    readings: Arc&lt;Mutex&lt;Vec&lt;TemperatureReading&gt;&gt;&gt;,
    capacity: usize,
}

#[cfg(not(feature = "std"))]
pub struct TemperatureStore&lt;const N: usize&gt; {
    readings: Vec&lt;TemperatureReading, N&gt;,
    total_readings: u32,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="build-configuration-examples"><a class="header" href="#build-configuration-examples">Build Configuration Examples</a></h3>
<pre><code class="language-bash"># Desktop build with all features
cargo build --features "std,serde,async"

# Embedded build minimal features
cargo build --no-default-features --features "serde"

# ESP32 build
cargo build --target riscv32imc-esp-espidf --no-default-features
</code></pre>
<h2 id="cross-compilation-for-embedded-targets"><a class="header" href="#cross-compilation-for-embedded-targets">Cross-Compilation for Embedded Targets</a></h2>
<h3 id="esp32-c3-target-setup"><a class="header" href="#esp32-c3-target-setup">ESP32-C3 Target Setup</a></h3>
<pre><code class="language-bash"># Install ESP32 toolchain
curl -LO https://github.com/esp-rs/rust-build/releases/download/v1.75.0.0/install-rust-toolchain.sh
chmod +x install-rust-toolchain.sh
./install-rust-toolchain.sh

# Install additional tools
cargo install espflash
cargo install ldproxy
</code></pre>
<h3 id="cross-compilation-configuration"><a class="header" href="#cross-compilation-configuration">Cross-Compilation Configuration</a></h3>
<pre><code class="language-toml"># .cargo/config.toml
[build]
# Default target for local development
target = "x86_64-unknown-linux-gnu"

[target.riscv32imc-esp-espidf]
linker = "ldproxy"
runner = "espflash flash --monitor"

[target.riscv32imc-unknown-none-elf]
linker = "riscv32-esp-elf-gcc"
runner = "probe-rs run --chip esp32c3"

[env]
# ESP-IDF specific environment variables
ESP_IDF_VERSION = "v5.1.2"
</code></pre>
<h3 id="multi-target-build-scripts"><a class="header" href="#multi-target-build-scripts">Multi-Target Build Scripts</a></h3>
<pre><code class="language-bash"># build.sh - Cross-platform build script
#!/bin/bash
set -e

echo "Building temperature monitor for multiple targets..."

# Desktop builds
echo "Building for desktop..."
cargo build --workspace --release

# Embedded simulation build
echo "Building embedded simulation..."
cargo build -p temp_embedded --no-default-features --release

# ESP32-C3 build
echo "Building for ESP32-C3..."
cargo build -p temp_esp32 \
    --target riscv32imc-esp-espidf \
    --no-default-features \
    --features "embedded" \
    --release

echo "All builds completed successfully!"
</code></pre>
<h2 id="binary-size-optimization-for-embedded"><a class="header" href="#binary-size-optimization-for-embedded">Binary Size Optimization for Embedded</a></h2>
<h3 id="embedded-specific-profile"><a class="header" href="#embedded-specific-profile">Embedded-Specific Profile</a></h3>
<pre><code class="language-toml"># Cargo.toml
[profile.embedded]
inherits = "release"
opt-level = "z"           # Optimize for size over speed
lto = true               # Link-time optimization
codegen-units = 1        # Better optimization
strip = "symbols"        # Remove debug symbols
panic = "abort"          # Smaller panic handler
overflow-checks = false  # Disable overflow checks

[profile.embedded.package.temp_esp32]
opt-level = "s"          # Slightly less aggressive for main binary
</code></pre>
<h3 id="size-analysis-tools"><a class="header" href="#size-analysis-tools">Size Analysis Tools</a></h3>
<pre><code class="language-bash"># Analyze binary size breakdown
cargo bloat --release --target riscv32imc-esp-espidf -p temp_esp32

# Size comparison between profiles
cargo size --release -- --format=sysv
cargo size --profile embedded -- --format=sysv

# Memory usage analysis
cargo nm --release | grep -E "(\.text|\.data|\.bss)" | sort
</code></pre>
<h3 id="code-size-optimization-techniques"><a class="header" href="#code-size-optimization-techniques">Code Size Optimization Techniques</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Use const fn for compile-time computation
const fn calculate_buffer_size(sensor_count: usize) -&gt; usize {
    sensor_count * 64 // 64 readings per sensor
}

// Prefer arrays over Vec when size is known
const SENSORS: usize = 3;
const BUFFER_SIZE: usize = calculate_buffer_size(SENSORS);
static mut READINGS_BUFFER: [TemperatureReading; BUFFER_SIZE] = [TemperatureReading::empty(); BUFFER_SIZE];

// Use #[inline] judiciously
#[inline]
fn critical_fast_path(temp: f32) -&gt; bool {
    temp &gt; 50.0 // Critical temperature check
}

// Avoid large dependencies for simple operations
// Instead of regex for simple patterns
fn parse_sensor_id(input: &amp;str) -&gt; Option&lt;u8&gt; {
    if input.starts_with("temp_") &amp;&amp; input.len() == 7 {
        input.chars().last()?.to_digit(10).map(|d| d as u8)
    } else {
        None
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="cicd-for-embedded-systems"><a class="header" href="#cicd-for-embedded-systems">CI/CD for Embedded Systems</a></h2>
<h3 id="comprehensive-github-actions-workflow"><a class="header" href="#comprehensive-github-actions-workflow">Comprehensive GitHub Actions Workflow</a></h3>
<pre><code class="language-yaml"># .github/workflows/ci.yml
name: Temperature Monitor CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  CARGO_TERM_COLOR: always

jobs:
  test:
    name: Test Suite
    runs-on: ubuntu-latest
    strategy:
      matrix:
        rust: [stable, beta]
    steps:
    - uses: actions/checkout@v4

    - name: Install Rust toolchain
      uses: dtolnay/rust-toolchain@stable
      with:
        toolchain: ${{ matrix.rust }}
        components: rustfmt, clippy

    - name: Cache cargo dependencies
      uses: actions/cache@v3
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
          target
        key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}

    - name: Check formatting
      run: cargo fmt --all -- --check

    - name: Clippy analysis
      run: cargo clippy --workspace --all-targets --all-features -- -D warnings

    - name: Test std builds
      run: cargo test --workspace --all-features

    - name: Test no_std builds
      run: cargo test -p temp_core -p temp_embedded --no-default-features

  cross-compile:
    name: Cross Compilation
    runs-on: ubuntu-latest
    strategy:
      matrix:
        target:
          - x86_64-pc-windows-gnu
          - aarch64-unknown-linux-gnu
          - riscv32imc-unknown-none-elf
    steps:
    - uses: actions/checkout@v4
    - uses: dtolnay/rust-toolchain@stable
      with:
        targets: ${{ matrix.target }}

    - name: Install cross-compilation tools
      if: matrix.target == 'riscv32imc-unknown-none-elf'
      run: |
        curl -LO https://github.com/esp-rs/rust-build/releases/download/v1.75.0.0/install-rust-toolchain.sh
        chmod +x install-rust-toolchain.sh
        ./install-rust-toolchain.sh --extra-crates "ldproxy"

    - name: Build for target
      run: |
        if [[ "${{ matrix.target }}" == "riscv32imc-unknown-none-elf" ]]; then
          cargo build -p temp_embedded --target ${{ matrix.target }} --no-default-features
        else
          cargo build --workspace --target ${{ matrix.target }} --release
        fi

  embedded-test:
    name: Embedded Testing
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - uses: dtolnay/rust-toolchain@stable

    - name: Install embedded testing tools
      run: |
        cargo install probe-rs --features cli
        cargo install cargo-embed

    - name: Test embedded builds
      run: |
        cargo check -p temp_embedded --target thumbv7em-none-eabihf --no-default-features
        cargo test -p temp_embedded --lib # Run tests on host

  size-analysis:
    name: Binary Size Analysis
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - uses: dtolnay/rust-toolchain@stable
    - run: cargo install cargo-bloat cargo-size

    - name: Analyze binary sizes
      run: |
        cargo build --release -p temp_esp32
        cargo size --release -p temp_esp32 -- --format=sysv
        cargo bloat --release -p temp_esp32
</code></pre>
<h3 id="release-pipeline"><a class="header" href="#release-pipeline">Release Pipeline</a></h3>
<pre><code class="language-yaml"># .github/workflows/release.yml
name: Release

on:
  release:
    types: [created]

jobs:
  distribute:
    name: Distribute Binaries
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            suffix: ""
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            suffix: ".exe"
          - os: macos-latest
            target: x86_64-apple-darwin
            suffix: ""

    steps:
    - uses: actions/checkout@v4
    - uses: dtolnay/rust-toolchain@stable
      with:
        targets: ${{ matrix.target }}

    - name: Build release binary
      run: cargo build --release -p temp_protocol --target ${{ matrix.target }}

    - name: Upload release asset
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ github.event.release.upload_url }}
        asset_path: ./target/${{ matrix.target }}/release/temp_monitor${{ matrix.suffix }}
        asset_name: temp_monitor-${{ matrix.target }}${{ matrix.suffix }}
        asset_content_type: application/octet-stream
</code></pre>
<h2 id="modern-distribution-with-cargo-dist"><a class="header" href="#modern-distribution-with-cargo-dist">Modern Distribution with cargo-dist</a></h2>
<p>cargo-dist automates building and distributing Rust binaries across platforms.</p>
<h3 id="cargo-dist-configuration"><a class="header" href="#cargo-dist-configuration">cargo-dist Configuration</a></h3>
<pre><code class="language-toml"># Cargo.toml
[workspace.metadata.dist]
# The preferred cargo-dist version to use in CI
cargo-dist-version = "0.8.0"
# CI backends to support
ci = ["github"]
# The installers to generate for each app
installers = ["shell", "powershell", "homebrew"]
# Target platforms to build apps for ("rustc -vV" to find yours)
targets = [
  "aarch64-apple-darwin",
  "x86_64-apple-darwin",
  "x86_64-pc-windows-msvc",
  "x86_64-unknown-linux-gnu"
]

# The archive format to use for windows builds (defaults to .zip)
windows-archive = ".tar.gz"
# The archive format to use for non-windows builds (defaults to .tar.xz)
unix-archive = ".tar.gz"

[workspace.metadata.dist.dependencies.apt]
cmake = '*'
</code></pre>
<h3 id="initialize-cargo-dist"><a class="header" href="#initialize-cargo-dist">Initialize cargo-dist</a></h3>
<pre><code class="language-bash"># Initialize cargo-dist in the workspace
cargo dist init

# Generate CI configuration
cargo dist generate-ci

# Build local release
cargo dist build

# Check what cargo-dist would build
cargo dist plan
</code></pre>
<h2 id="embedded-deployment-tools"><a class="header" href="#embedded-deployment-tools">Embedded Deployment Tools</a></h2>
<h3 id="probe-rs-for-hardware-debugging"><a class="header" href="#probe-rs-for-hardware-debugging">probe-rs for Hardware Debugging</a></h3>
<pre><code class="language-toml"># .cargo/config.toml
[target.thumbv7em-none-eabihf]
runner = "probe-rs run --chip STM32F401CCUx"

[target.riscv32imc-esp-espidf]
runner = "espflash flash --monitor"
</code></pre>
<h3 id="deploy-script-example"><a class="header" href="#deploy-script-example">Deploy Script Example</a></h3>
<pre><code class="language-bash">#!/bin/bash
# deploy.sh - Deploy to ESP32-C3

set -e

CHIP="esp32c3"
PORT="/dev/ttyUSB0"

echo "Building temperature monitor for ESP32-C3..."
cargo build --release -p temp_esp32 \
    --target riscv32imc-esp-espidf \
    --no-default-features

echo "Flashing to ESP32-C3..."
espflash flash \
    --chip $CHIP \
    --port $PORT \
    --baud 921600 \
    target/riscv32imc-esp-espidf/release/temp_esp32

echo "Monitoring serial output..."
espflash monitor --port $PORT
</code></pre>
<h3 id="probe-rs-configuration"><a class="header" href="#probe-rs-configuration">probe-rs Configuration</a></h3>
<pre><code class="language-toml"># Embed.toml
[default.probe]
protocol = "Swd"
speed = 20_000

[default.flashing]
enabled = true
restore_unwritten_bytes = false

[default.general]
chip = "STM32F401CCUx"

[default.reset]
enabled = true
halt_afterwards = false

[default.gdb]
enabled = false
</code></pre>
<h2 id="language-comparison-build--deploy"><a class="header" href="#language-comparison-build--deploy">Language Comparison: Build &amp; Deploy</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th><strong>Rust</strong></th><th><strong>C/C++</strong></th><th><strong>C#</strong></th><th><strong>Go</strong></th></tr></thead><tbody>
<tr><td><strong>Package Manager</strong></td><td>Built-in (Cargo)</td><td>External (vcpkg, conan)</td><td>Built-in (NuGet)</td><td>Built-in (go mod)</td></tr>
<tr><td><strong>Build System</strong></td><td>Cargo</td><td>CMake, Make, Ninja</td><td>MSBuild</td><td>Built-in</td></tr>
<tr><td><strong>Cross-compilation</strong></td><td>Native support</td><td>Complex toolchain setup</td><td>Limited</td><td>Excellent</td></tr>
<tr><td><strong>Embedded Support</strong></td><td>First-class</td><td>Traditional choice</td><td>Limited</td><td>Not suitable</td></tr>
<tr><td><strong>Binary Size</strong></td><td>&lt;50KB optimized</td><td>&lt;20KB (C), &gt;1MB (C++)</td><td>&gt;10MB with runtime</td><td>&gt;5MB</td></tr>
<tr><td><strong>CI/CD Complexity</strong></td><td>Simple YAML</td><td>Complex scripts</td><td>Azure DevOps integration</td><td>Simple</td></tr>
<tr><td><strong>Deployment</strong></td><td>Single binary</td><td>Dependencies/static linking</td><td>Runtime required</td><td>Single binary</td></tr>
</tbody></table>
</div>
<h2 id="exercise-deploy-temperature-monitor-to-production"><a class="header" href="#exercise-deploy-temperature-monitor-to-production">Exercise: Deploy Temperature Monitor to Production</a></h2>
<p>Build a complete deployment pipeline for your temperature monitoring system that works across desktop and embedded targets.</p>
<h3 id="requirements"><a class="header" href="#requirements">Requirements</a></h3>
<p>Your deployment system should:</p>
<ol>
<li>
<p><strong>Multi-Target Building</strong>:</p>
<ul>
<li>Desktop version with full std features</li>
<li>Embedded version with no_std constraints</li>
<li>ESP32-C3 version for hardware deployment</li>
</ul>
</li>
<li>
<p><strong>Feature Configuration</strong>:</p>
<ul>
<li><code>std</code> feature for desktop builds</li>
<li><code>embedded</code> feature for no_std builds</li>
<li><code>simulation</code> feature for testing without hardware</li>
</ul>
</li>
<li>
<p><strong>Size Optimization</strong>:</p>
<ul>
<li>Optimized profiles for embedded deployment</li>
<li>Binary size analysis and reporting</li>
</ul>
</li>
<li>
<p><strong>CI/CD Pipeline</strong>:</p>
<ul>
<li>Automated testing for both std and no_std builds</li>
<li>Cross-compilation verification</li>
<li>Release artifact generation</li>
</ul>
</li>
<li>
<p><strong>Distribution</strong>:</p>
<ul>
<li>Desktop binaries for multiple platforms</li>
<li>Embedded firmware images</li>
<li>Installation scripts</li>
</ul>
</li>
</ol>
<h3 id="starting-configuration"><a class="header" href="#starting-configuration">Starting Configuration</a></h3>
<p>Your workspace should already have the basic structure. Enhance it with deployment-specific configuration:</p>
<pre><code class="language-toml"># Cargo.toml (add these sections)
[workspace.metadata.dist]
cargo-dist-version = "0.8.0"
ci = ["github"]
targets = ["x86_64-unknown-linux-gnu", "x86_64-pc-windows-msvc", "x86_64-apple-darwin"]

[profile.embedded]
inherits = "release"
opt-level = "z"
lto = true
strip = true
panic = "abort"

[profile.simulation]
inherits = "dev"
debug = true
opt-level = 1
</code></pre>
<h3 id="implementation-steps"><a class="header" href="#implementation-steps">Implementation Steps</a></h3>
<ol>
<li>
<p><strong>Configure Features</strong>: Set up conditional compilation for different deployment targets</p>
</li>
<li>
<p><strong>Optimize Builds</strong>: Create profiles optimized for embedded deployment</p>
</li>
<li>
<p><strong>Set Up Cross-Compilation</strong>: Configure toolchains for ESP32-C3 target</p>
</li>
<li>
<p><strong>Create Build Scripts</strong>: Automate building for multiple targets</p>
</li>
<li>
<p><strong>Implement CI/CD</strong>: Create GitHub Actions workflow for automated testing and deployment</p>
</li>
<li>
<p><strong>Test Deployment</strong>: Verify builds work on target platforms</p>
</li>
</ol>
<h3 id="success-criteria"><a class="header" href="#success-criteria">Success Criteria</a></h3>
<ul>
<li>Desktop version runs with full features and networking</li>
<li>Embedded version compiles to &lt;50KB binary</li>
<li>CI pipeline successfully builds and tests all targets</li>
<li>Binary size analysis reports memory usage</li>
<li>ESP32-C3 version can be flashed to hardware</li>
<li>Release artifacts are automatically generated</li>
</ul>
<h3 id="extension-ideas"><a class="header" href="#extension-ideas">Extension Ideas</a></h3>
<ol>
<li><strong>Over-the-Air Updates</strong>: Implement firmware update mechanism</li>
<li><strong>Docker Deployment</strong>: Create containerized version for server deployment</li>
<li><strong>Package Distribution</strong>: Publish crates to crates.io</li>
<li><strong>Hardware Simulation</strong>: Test embedded code without physical hardware</li>
<li><strong>Performance Benchmarks</strong>: Automated performance testing in CI</li>
</ol>
<h2 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways</a></h2>
<ol>
<li><strong>Workspaces Scale</strong>: Multi-crate workspaces manage complexity in embedded projects</li>
<li><strong>Features Enable Flexibility</strong>: Same codebase works across std and no_std environments</li>
<li><strong>Cross-Compilation is Powerful</strong>: Build for any target from any development machine</li>
<li><strong>Size Matters in Embedded</strong>: Optimization profiles crucial for resource-constrained systems</li>
<li><strong>CI/CD Prevents Regressions</strong>: Automated testing catches issues across all targets</li>
<li><strong>Modern Tooling Simplifies Deployment</strong>: cargo-dist and probe-rs streamline distribution</li>
<li><strong>Rust Shines in Embedded</strong>: Memory safety without performance cost ideal for embedded systems</li>
</ol>
<p>The Rust ecosystem provides unmatched tooling for building, testing, and deploying embedded systems while maintaining the same high-level abstractions used in desktop development.</p>
<p><strong>Next</strong>: In Chapter 19, we'll bring everything together in the final capstone integration, deploying our complete temperature monitoring system to ESP32-C3 hardware.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../day3/17_no_std.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../day3/19_capstone.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../day3/17_no_std.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../day3/19_capstone.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
