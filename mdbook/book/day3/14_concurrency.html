<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Concurrency Fundamentals</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-14-concurrency-fundamentals"><a class="header" href="#chapter-14-concurrency-fundamentals">Chapter 14: Concurrency Fundamentals</a></h1>
<h2 id="learning-objectives"><a class="header" href="#learning-objectives">Learning Objectives</a></h2>
<ul>
<li>Master Rust's thread-safe shared state management using <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> and <code>Arc&lt;RwLock&lt;T&gt;&gt;</code></li>
<li>Understand message passing with channels (<code>mpsc</code>) and when to use each approach</li>
<li>Learn about <code>Send</code> and <code>Sync</code> traits and their role in thread safety</li>
<li>Apply deadlock prevention strategies in multi-threaded code</li>
<li>Use Rayon for data parallelism and performance optimization</li>
<li>Compare Rust's concurrency model to C++/C# threading approaches</li>
</ul>
<h2 id="thread-safety-send-and-sync-traits"><a class="header" href="#thread-safety-send-and-sync-traits">Thread Safety: Send and Sync Traits</a></h2>
<p>Rust's concurrency safety is built on two key traits:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Send: Types that can be transferred between threads
// Sync: Types that can be safely shared between threads (T is Sync if &amp;T is Send)

use std::thread;
use std::sync::{Arc, Mutex, RwLock};
use std::time::Duration;

// Most types are Send and Sync automatically
fn demonstrate_send_sync() {
    let data = vec![1, 2, 3, 4, 5];
    
    // This works because Vec&lt;i32&gt; is Send
    let handle = thread::spawn(move || {
        println!("Data in thread: {:?}", data);
    });
    
    handle.join().unwrap();
}
<span class="boring">}</span></code></pre></pre>
<p><strong>C++/C# Comparison:</strong></p>
<ul>
<li><strong>C++</strong>: No built-in thread safety guarantees; developers must manually ensure thread safety</li>
<li><strong>C#</strong>: Thread safety is runtime-checked; race conditions possible</li>
<li><strong>Rust</strong>: Thread safety is compile-time guaranteed through Send/Sync traits</li>
</ul>
<h2 id="shared-state-with-arcmutex"><a class="header" href="#shared-state-with-arcmutex">Shared State with Arc&lt;Mutex<T>&gt;</a></h2>
<p><code>Arc&lt;Mutex&lt;T&gt;&gt;</code> is the primary pattern for shared mutable state:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Arc, Mutex};
use std::thread;

fn shared_counter_example() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    
    for i in 0..10 {
        let counter_clone = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            for _ in 0..1000 {
                let mut num = counter_clone.lock().unwrap();
                *num += 1;
                // Mutex is automatically released when `num` goes out of scope
            }
            println!("Thread {} finished", i);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("Final counter value: {}", *counter.lock().unwrap());
    // Output: Final counter value: 10000
}

// Better error handling with Mutex
fn safe_shared_counter() -&gt; Result&lt;i32, Box&lt;dyn std::error::Error&gt;&gt; {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    
    for _ in 0..10 {
        let counter_clone = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || -&gt; Result&lt;(), Box&lt;dyn std::error::Error + Send&gt;&gt; {
            for _ in 0..1000 {
                let mut num = counter_clone.lock()
                    .map_err(|e| format!("Mutex poisoned: {}", e))?;
                *num += 1;
            }
            Ok(())
        });
        handles.push(handle);
    }
    
    // Collect results and handle errors
    for handle in handles {
        handle.join().unwrap()?;
    }
    
    let final_value = counter.lock()
        .map_err(|e| format!("Final lock failed: {}", e))?;
    Ok(*final_value)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="reader-writer-locks-arcrwlock"><a class="header" href="#reader-writer-locks-arcrwlock">Reader-Writer Locks: Arc&lt;RwLock<T>&gt;</a></h2>
<p>When you have many readers and few writers, <code>RwLock</code> can be more efficient:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Arc, RwLock};
use std::thread;
use std::time::Duration;

fn rwlock_example() {
    let data = Arc::new(RwLock::new(vec![1, 2, 3, 4, 5]));
    let mut handles = vec![];
    
    // Spawn reader threads
    for i in 0..5 {
        let data_clone = Arc::clone(&amp;data);
        let handle = thread::spawn(move || {
            for _ in 0..10 {
                let data_guard = data_clone.read().unwrap();
                println!("Reader {} sees: {:?}", i, *data_guard);
                thread::sleep(Duration::from_millis(10));
            }
        });
        handles.push(handle);
    }
    
    // Spawn writer threads
    for i in 0..2 {
        let data_clone = Arc::clone(&amp;data);
        let handle = thread::spawn(move || {
            for j in 0..5 {
                let mut data_guard = data_clone.write().unwrap();
                data_guard.push(i * 10 + j);
                println!("Writer {} added: {}", i, i * 10 + j);
                thread::sleep(Duration::from_millis(50));
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("Final data: {:?}", *data.read().unwrap());
}
<span class="boring">}</span></code></pre></pre>
<h2 id="message-passing-with-channels"><a class="header" href="#message-passing-with-channels">Message Passing with Channels</a></h2>
<p>Channels provide a safer alternative to shared state for many use cases:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn basic_channel_example() {
    let (tx, rx) = mpsc::channel();
    
    // Spawn producer thread
    thread::spawn(move || {
        let messages = vec![
            "Hello",
            "from",
            "the",
            "producer",
            "thread"
        ];
        
        for msg in messages {
            tx.send(msg).unwrap();
            thread::sleep(Duration::from_millis(100));
        }
        // tx is dropped here, which closes the channel
    });
    
    // Receive messages in main thread
    for received in rx {
        println!("Received: {}", received);
    }
}

// Multiple producer, single consumer
fn mpsc_example() {
    let (tx, rx) = mpsc::channel();
    
    // Clone sender for multiple producers
    for i in 0..3 {
        let tx_clone = tx.clone();
        thread::spawn(move || {
            for j in 0..5 {
                let msg = format!("Message {}-{}", i, j);
                tx_clone.send(msg).unwrap();
                thread::sleep(Duration::from_millis(10));
            }
        });
    }
    
    // Drop the original sender
    drop(tx);
    
    // Collect all messages
    let mut messages = Vec::new();
    for received in rx {
        messages.push(received);
    }
    
    messages.sort(); // Messages may arrive out of order
    println!("All messages: {:?}", messages);
}

// Synchronous channel for backpressure
fn sync_channel_example() {
    let (tx, rx) = mpsc::sync_channel(2); // Buffer size of 2
    
    thread::spawn(move || {
        for i in 0..5 {
            println!("Sending {}", i);
            tx.send(i).unwrap(); // This will block when buffer is full
            println!("Sent {}", i);
        }
    });
    
    thread::sleep(Duration::from_secs(1));
    
    for received in rx {
        println!("Received: {}", received);
        thread::sleep(Duration::from_millis(500)); // Slow consumer
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="producer-consumer-pattern"><a class="header" href="#producer-consumer-pattern">Producer-Consumer Pattern</a></h2>
<p>A common concurrency pattern combining channels and shared state:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{mpsc, Arc, Mutex};
use std::thread;
use std::time::Duration;

#[derive(Debug, Clone)]
struct WorkItem {
    id: u32,
    data: String,
}

#[derive(Debug)]
struct WorkResult {
    item_id: u32,
    result: String,
    processing_time_ms: u64,
}

fn producer_consumer_example() {
    let (work_tx, work_rx) = mpsc::channel::&lt;WorkItem&gt;();
    let (result_tx, result_rx) = mpsc::channel::&lt;WorkResult&gt;();
    let work_rx = Arc::new(Mutex::new(work_rx));
    
    // Spawn multiple worker threads
    let num_workers = 3;
    for worker_id in 0..num_workers {
        let work_rx_clone = Arc::clone(&amp;work_rx);
        let result_tx_clone = result_tx.clone();
        
        thread::spawn(move || {
            loop {
                let work_item = {
                    let rx = work_rx_clone.lock().unwrap();
                    rx.recv()
                };
                
                match work_item {
                    Ok(item) =&gt; {
                        let start = std::time::Instant::now();
                        
                        // Simulate work
                        let processed_data = item.data.to_uppercase();
                        thread::sleep(Duration::from_millis(100 + (item.id % 3) * 50));
                        
                        let result = WorkResult {
                            item_id: item.id,
                            result: processed_data,
                            processing_time_ms: start.elapsed().as_millis() as u64,
                        };
                        
                        result_tx_clone.send(result).unwrap();
                        println!("Worker {} processed item {}", worker_id, item.id);
                    }
                    Err(_) =&gt; {
                        println!("Worker {} shutting down", worker_id);
                        break;
                    }
                }
            }
        });
    }
    
    // Producer thread
    thread::spawn(move || {
        for i in 0..10 {
            let item = WorkItem {
                id: i,
                data: format!("task-{}", i),
            };
            work_tx.send(item).unwrap();
            thread::sleep(Duration::from_millis(50));
        }
        // Channel closes when work_tx is dropped
    });
    
    // Drop our copy of result_tx so the channel closes when workers are done
    drop(result_tx);
    
    // Collect results
    let mut results = Vec::new();
    for result in result_rx {
        results.push(result);
    }
    
    results.sort_by_key(|r| r.item_id);
    for result in results {
        println!("Result: {:?}", result);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="deadlock-prevention"><a class="header" href="#deadlock-prevention">Deadlock Prevention</a></h2>
<p>Common strategies to avoid deadlocks:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

// BAD: Potential deadlock
fn deadlock_example() {
    let resource1 = Arc::new(Mutex::new(1));
    let resource2 = Arc::new(Mutex::new(2));
    
    let r1_clone = Arc::clone(&amp;resource1);
    let r2_clone = Arc::clone(&amp;resource2);
    
    let handle1 = thread::spawn(move || {
        let _guard1 = r1_clone.lock().unwrap();
        thread::sleep(Duration::from_millis(10)); // Simulate work
        let _guard2 = r2_clone.lock().unwrap(); // Potential deadlock here
        println!("Thread 1 completed");
    });
    
    let handle2 = thread::spawn(move || {
        let _guard2 = resource2.lock().unwrap();
        thread::sleep(Duration::from_millis(10)); // Simulate work
        let _guard1 = resource1.lock().unwrap(); // Potential deadlock here
        println!("Thread 2 completed");
    });
    
    handle1.join().unwrap();
    handle2.join().unwrap();
}

// GOOD: Ordered lock acquisition prevents deadlock
fn deadlock_prevention() {
    let resource1 = Arc::new(Mutex::new(1));
    let resource2 = Arc::new(Mutex::new(2));
    
    let r1_clone = Arc::clone(&amp;resource1);
    let r2_clone = Arc::clone(&amp;resource2);
    
    let handle1 = thread::spawn(move || {
        // Always lock resource1 first, then resource2
        let _guard1 = r1_clone.lock().unwrap();
        thread::sleep(Duration::from_millis(10));
        let _guard2 = r2_clone.lock().unwrap();
        println!("Thread 1 completed safely");
    });
    
    let handle2 = thread::spawn(move || {
        // Same order: resource1 first, then resource2
        let _guard1 = resource1.lock().unwrap();
        thread::sleep(Duration::from_millis(10));
        let _guard2 = resource2.lock().unwrap();
        println!("Thread 2 completed safely");
    });
    
    handle1.join().unwrap();
    handle2.join().unwrap();
}

// Using try_lock to avoid blocking
fn try_lock_pattern() {
    let resource = Arc::new(Mutex::new(42));
    let resource_clone = Arc::clone(&amp;resource);
    
    thread::spawn(move || {
        let _guard = resource_clone.lock().unwrap();
        thread::sleep(Duration::from_millis(100)); // Hold lock for a while
    });
    
    thread::sleep(Duration::from_millis(10)); // Let other thread acquire lock
    
    match resource.try_lock() {
        Ok(guard) =&gt; println!("Got lock: {}", *guard),
        Err(_) =&gt; println!("Lock is busy, doing something else instead"),
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="data-parallelism-with-rayon"><a class="header" href="#data-parallelism-with-rayon">Data Parallelism with Rayon</a></h2>
<p>Rayon provides easy data parallelism without explicit thread management:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rayon::prelude::*;

fn rayon_examples() {
    // Parallel iterator operations
    let numbers: Vec&lt;i32&gt; = (0..1_000_000).collect();
    
    // Parallel map
    let squares: Vec&lt;i32&gt; = numbers
        .par_iter()
        .map(|&amp;x| x * x)
        .collect();
    
    println!("First 10 squares: {:?}", &amp;squares[..10]);
    
    // Parallel filtering and reduction
    let sum_of_even_squares: i32 = numbers
        .par_iter()
        .filter(|&amp;&amp;x| x % 2 == 0)
        .map(|&amp;x| x * x)
        .sum();
    
    println!("Sum of even squares: {}", sum_of_even_squares);
    
    // Parallel sorting
    let mut data: Vec&lt;i32&gt; = (0..100_000).rev().collect();
    data.par_sort_unstable();
    println!("Data is sorted: {}", is_sorted(&amp;data));
}

fn is_sorted&lt;T: Ord&gt;(slice: &amp;[T]) -&gt; bool {
    slice.windows(2).all(|w| w[0] &lt;= w[1])
}

// Custom parallel work
fn parallel_file_processing() {
    let filenames: Vec&lt;String&gt; = (0..100)
        .map(|i| format!("file_{}.txt", i))
        .collect();
    
    let results: Vec&lt;_&gt; = filenames
        .par_iter()
        .map(|filename| {
            // Simulate file processing
            let size = filename.len() * 1024; // Mock file size
            (filename.clone(), size)
        })
        .collect();
    
    let total_size: usize = results.iter().map(|(_, size)| size).sum();
    println!("Processed {} files, total size: {} bytes", results.len(), total_size);
}

// Parallel fold with custom operations
fn parallel_fold_example() {
    let numbers: Vec&lt;f64&gt; = (1..=1_000_000).map(|x| x as f64).collect();
    
    // Calculate mean using parallel fold
    let (sum, count) = numbers
        .par_iter()
        .fold(|| (0.0, 0), |acc, &amp;x| (acc.0 + x, acc.1 + 1))
        .reduce(|| (0.0, 0), |a, b| (a.0 + b.0, a.1 + b.1));
    
    let mean = sum / count as f64;
    println!("Mean: {}", mean);
    
    // Calculate standard deviation
    let variance = numbers
        .par_iter()
        .map(|&amp;x| (x - mean).powi(2))
        .sum::&lt;f64&gt;() / count as f64;
    
    println!("Standard deviation: {}", variance.sqrt());
}
<span class="boring">}</span></code></pre></pre>
<h2 id="common-pitfalls-and-solutions"><a class="header" href="#common-pitfalls-and-solutions">Common Pitfalls and Solutions</a></h2>
<h3 id="1-mutex-poisoning"><a class="header" href="#1-mutex-poisoning">1. Mutex Poisoning</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Arc, Mutex};
use std::thread;

fn handle_poisoned_mutex() {
    let data = Arc::new(Mutex::new(vec![1, 2, 3]));
    let data_clone = Arc::clone(&amp;data);
    
    // Thread that panics while holding the mutex
    let handle = thread::spawn(move || {
        let mut guard = data_clone.lock().unwrap();
        guard.push(4);
        panic!("Simulated panic!"); // This poisons the mutex
    });
    
    // This will fail
    let _ = handle.join();
    
    // Handle poisoned mutex properly
    match data.lock() {
        Ok(guard) =&gt; println!("Data: {:?}", *guard),
        Err(poisoned) =&gt; {
            println!("Mutex was poisoned, but we can recover the data");
            let guard = poisoned.into_inner();
            println!("Recovered data: {:?}", *guard);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-avoiding-arcmutex-when-possible"><a class="header" href="#2-avoiding-arcmutex-when-possible">2. Avoiding Arc&lt;Mutex<T>&gt; When Possible</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::mpsc;
use std::thread;

// Instead of shared mutable state, use message passing
fn prefer_message_passing() {
    let (tx, rx) = mpsc::channel();
    
    // Spawn data processor thread
    thread::spawn(move || {
        let mut data = vec![1, 2, 3];
        
        for command in rx {
            match command {
                Command::Add(value) =&gt; data.push(value),
                Command::Get(response_tx) =&gt; {
                    response_tx.send(data.clone()).unwrap();
                }
                Command::Stop =&gt; break,
            }
        }
    });
    
    // Use the data processor
    tx.send(Command::Add(4)).unwrap();
    tx.send(Command::Add(5)).unwrap();
    
    let (response_tx, response_rx) = mpsc::channel();
    tx.send(Command::Get(response_tx)).unwrap();
    let data = response_rx.recv().unwrap();
    
    println!("Data: {:?}", data);
    tx.send(Command::Stop).unwrap();
}

#[derive(Debug)]
enum Command {
    Add(i32),
    Get(mpsc::Sender&lt;Vec&lt;i32&gt;&gt;),
    Stop,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<h3 id="exercise-1-thread-pool-implementation"><a class="header" href="#exercise-1-thread-pool-implementation">Exercise 1: Thread Pool Implementation</a></h3>
<p>Create a simple thread pool that can execute closures:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Arc, Mutex, mpsc};
use std::thread;

struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Job&gt;,
}

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    pub fn new(size: usize) -&gt; ThreadPool {
        // TODO: Implement thread pool creation
        unimplemented!()
    }
    
    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        // TODO: Send job to worker thread
        unimplemented!()
    }
}

struct Worker {
    id: usize,
    thread: thread::JoinHandle&lt;()&gt;,
}

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // TODO: Create worker that processes jobs from receiver
        unimplemented!()
    }
}

// Test your implementation
fn test_thread_pool() {
    let pool = ThreadPool::new(4);
    
    for i in 0..8 {
        pool.execute(move || {
            println!("Executing task {}", i);
            thread::sleep(Duration::from_millis(100));
        });
    }
    
    thread::sleep(Duration::from_secs(1));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="exercise-2-concurrent-cache"><a class="header" href="#exercise-2-concurrent-cache">Exercise 2: Concurrent Cache</a></h3>
<p>Implement a thread-safe cache with expiration:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use std::time::{Duration, Instant};

struct CacheEntry&lt;T&gt; {
    value: T,
    expires_at: Instant,
}

struct Cache&lt;K, V&gt; {
    data: Arc&lt;RwLock&lt;HashMap&lt;K, CacheEntry&lt;V&gt;&gt;&gt;&gt;,
    default_ttl: Duration,
}

impl&lt;K, V&gt; Cache&lt;K, V&gt;
where
    K: Clone + Eq + std::hash::Hash,
    V: Clone,
{
    pub fn new(default_ttl: Duration) -&gt; Self {
        // TODO: Implement cache creation
        unimplemented!()
    }
    
    pub fn get(&amp;self, key: &amp;K) -&gt; Option&lt;V&gt; {
        // TODO: Get value if not expired, clean up expired entries
        unimplemented!()
    }
    
    pub fn set(&amp;self, key: K, value: V) {
        // TODO: Insert value with expiration time
        unimplemented!()
    }
    
    pub fn set_with_ttl(&amp;self, key: K, value: V, ttl: Duration) {
        // TODO: Insert value with custom TTL
        unimplemented!()
    }
    
    pub fn cleanup_expired(&amp;self) {
        // TODO: Remove all expired entries
        unimplemented!()
    }
}

// Test concurrent access
fn test_concurrent_cache() {
    let cache = Arc::new(Cache::new(Duration::from_millis(100)));
    let mut handles = vec![];
    
    // Writer threads
    for i in 0..5 {
        let cache_clone = Arc::clone(&amp;cache);
        let handle = thread::spawn(move || {
            for j in 0..10 {
                cache_clone.set(format!("key-{}-{}", i, j), j);
                thread::sleep(Duration::from_millis(10));
            }
        });
        handles.push(handle);
    }
    
    // Reader threads
    for i in 0..3 {
        let cache_clone = Arc::clone(&amp;cache);
        let handle = thread::spawn(move || {
            for j in 0..20 {
                if let Some(value) = cache_clone.get(&amp;format!("key-0-{}", j % 10)) {
                    println!("Reader {} got value: {}", i, value);
                }
                thread::sleep(Duration::from_millis(5));
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="exercise-3-pipeline-processing"><a class="header" href="#exercise-3-pipeline-processing">Exercise 3: Pipeline Processing</a></h3>
<p>Create a multi-stage processing pipeline using channels:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::mpsc;
use std::thread;

#[derive(Debug, Clone)]
struct DataItem {
    id: u32,
    content: String,
}

// Create a processing pipeline: Input -&gt; Transform -&gt; Filter -&gt; Output
fn create_processing_pipeline() {
    let (input_tx, input_rx) = mpsc::channel();
    let (transform_tx, transform_rx) = mpsc::channel();
    let (filter_tx, filter_rx) = mpsc::channel();
    let (output_tx, output_rx) = mpsc::channel();
    
    // Stage 1: Transform (uppercase content)
    thread::spawn(move || {
        for item in input_rx {
            let transformed = DataItem {
                id: item.id,
                content: item.content.to_uppercase(),
            };
            transform_tx.send(transformed).unwrap();
        }
    });
    
    // Stage 2: Filter (only items with even IDs)
    thread::spawn(move || {
        // TODO: Implement filter stage
        unimplemented!()
    });
    
    // Stage 3: Output processing
    thread::spawn(move || {
        // TODO: Process filtered items
        unimplemented!()
    });
    
    // Generate input data
    for i in 0..20 {
        let item = DataItem {
            id: i,
            content: format!("item-{}", i),
        };
        input_tx.send(item).unwrap();
    }
    drop(input_tx);
    
    // Collect results
    for result in output_rx {
        println!("Final result: {:?}", result);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways</a></h2>
<ol>
<li><strong>Thread Safety is Guaranteed</strong>: Rust's <code>Send</code> and <code>Sync</code> traits ensure thread safety at compile time</li>
<li><strong>Choose the Right Pattern</strong>: Use <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> for shared state, channels for message passing</li>
<li><strong>RwLock for Read-Heavy Workloads</strong>: <code>Arc&lt;RwLock&lt;T&gt;&gt;</code> allows multiple concurrent readers</li>
<li><strong>Prevent Deadlocks</strong>: Use consistent lock ordering and consider <code>try_lock()</code> for non-blocking attempts</li>
<li><strong>Rayon for Data Parallelism</strong>: Easy parallel processing of collections with minimal code changes</li>
<li><strong>Handle Poisoned Mutexes</strong>: Always handle the case where a thread panics while holding a mutex</li>
<li><strong>Prefer Message Passing</strong>: Often cleaner and safer than shared mutable state</li>
<li><strong>Performance Considerations</strong>: Measure before optimizing; sometimes single-threaded code is faster</li>
</ol>
<p><strong>Next</strong>: In Chapter 14, we'll explore async programming, which provides concurrency without the overhead of OS threads.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../day3/13_testing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../day3/15_async.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../day3/13_testing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../day3/15_async.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
