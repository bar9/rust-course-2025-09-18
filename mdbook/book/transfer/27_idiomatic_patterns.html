<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Idiomatic Rust Patterns</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-27-idiomatic-rust-patterns"><a class="header" href="#chapter-27-idiomatic-rust-patterns">Chapter 27: Idiomatic Rust Patterns</a></h1>
<h2 id="learning-objectives"><a class="header" href="#learning-objectives">Learning Objectives</a></h2>
<ul>
<li>Master idiomatic Rust patterns and conventions</li>
<li>Understand "the Rust way" vs C++/.NET approaches</li>
<li>Learn common patterns from the Rust community</li>
<li>Write Rust that feels natural to Rust developers</li>
<li>Recognize and apply design patterns specific to Rust</li>
</ul>
<h2 id="the-rust-philosophy"><a class="header" href="#the-rust-philosophy">The Rust Philosophy</a></h2>
<h3 id="core-principles"><a class="header" href="#core-principles">Core Principles</a></h3>
<ol>
<li><strong>Explicit over implicit</strong> - Make intentions clear</li>
<li><strong>Composition over inheritance</strong> - Use traits and generics</li>
<li><strong>Zero-cost abstractions</strong> - Don't pay for what you don't use</li>
<li><strong>Fail fast and loudly</strong> - Catch errors at compile time</li>
<li><strong>Ownership clarity</strong> - Make ownership obvious</li>
</ol>
<h2 id="ownership-patterns"><a class="header" href="#ownership-patterns">Ownership Patterns</a></h2>
<h3 id="the-newtype-pattern"><a class="header" href="#the-newtype-pattern">The Newtype Pattern</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Wrap primitive types for type safety
struct Kilometers(f64);
struct Miles(f64);

impl Kilometers {
    fn to_miles(&amp;self) -&gt; Miles {
        Miles(self.0 * 0.621371)
    }
}

// Prevents mixing units
fn calculate_fuel_efficiency(distance: Kilometers, fuel: Liters) -&gt; KmPerLiter {
    KmPerLiter(distance.0 / fuel.0)
}

// Compare with C++
// typedef double Kilometers;  // Just an alias, no type safety
// using Miles = double;       // Same type, can mix them up
<span class="boring">}</span></code></pre></pre>
<h3 id="builder-pattern"><a class="header" href="#builder-pattern">Builder Pattern</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Idiomatic builder for complex structs
#[derive(Debug, Default)]
pub struct ServerConfig {
    host: String,
    port: u16,
    max_connections: usize,
    timeout: Duration,
}

#[derive(Default)]
pub struct ServerConfigBuilder {
    host: Option&lt;String&gt;,
    port: Option&lt;u16&gt;,
    max_connections: Option&lt;usize&gt;,
    timeout: Option&lt;Duration&gt;,
}

impl ServerConfigBuilder {
    pub fn new() -&gt; Self {
        Default::default()
    }
    
    pub fn host(mut self, host: impl Into&lt;String&gt;) -&gt; Self {
        self.host = Some(host.into());
        self
    }
    
    pub fn port(mut self, port: u16) -&gt; Self {
        self.port = Some(port);
        self
    }
    
    pub fn max_connections(mut self, max: usize) -&gt; Self {
        self.max_connections = Some(max);
        self
    }
    
    pub fn timeout(mut self, timeout: Duration) -&gt; Self {
        self.timeout = Some(timeout);
        self
    }
    
    pub fn build(self) -&gt; Result&lt;ServerConfig, &amp;'static str&gt; {
        Ok(ServerConfig {
            host: self.host.ok_or("host is required")?,
            port: self.port.unwrap_or(8080),
            max_connections: self.max_connections.unwrap_or(100),
            timeout: self.timeout.unwrap_or(Duration::from_secs(30)),
        })
    }
}

// Usage
let config = ServerConfigBuilder::new()
    .host("localhost")
    .port(3000)
    .timeout(Duration::from_secs(60))
    .build()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="raii-guards"><a class="header" href="#raii-guards">RAII Guards</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Idiomatic RAII pattern
pub struct TempDir {
    path: PathBuf,
}

impl TempDir {
    pub fn new(prefix: &amp;str) -&gt; io::Result&lt;Self&gt; {
        let path = std::env::temp_dir().join(format!("{}-{}", prefix, uuid()));
        std::fs::create_dir(&amp;path)?;
        Ok(TempDir { path })
    }
    
    pub fn path(&amp;self) -&gt; &amp;Path {
        &amp;self.path
    }
}

impl Drop for TempDir {
    fn drop(&amp;mut self) {
        let _ = std::fs::remove_dir_all(&amp;self.path);
    }
}

// Usage - directory automatically cleaned up
{
    let temp = TempDir::new("test")?;
    std::fs::write(temp.path().join("file.txt"), b"data")?;
    // Directory deleted when temp goes out of scope
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-patterns"><a class="header" href="#error-handling-patterns">Error Handling Patterns</a></h2>
<h3 id="custom-error-types"><a class="header" href="#custom-error-types">Custom Error Types</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Idiomatic error handling
#[derive(Debug, thiserror::Error)]
pub enum AppError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    
    #[error("Parse error: {0}")]
    Parse(#[from] std::num::ParseIntError),
    
    #[error("Database error: {0}")]
    Database(String),
    
    #[error("Not found: {resource}")]
    NotFound { resource: String },
    
    #[error("Invalid input: {message}")]
    InvalidInput { message: String },
}

// Result type alias for convenience
pub type Result&lt;T&gt; = std::result::Result&lt;T, AppError&gt;;

// Usage
fn process_file(path: &amp;Path) -&gt; Result&lt;Data&gt; {
    let contents = std::fs::read_to_string(path)?;  // Automatic conversion
    let parsed: i32 = contents.trim().parse()?;      // Automatic conversion
    
    if parsed &lt; 0 {
        return Err(AppError::InvalidInput {
            message: "Value must be positive".to_string(),
        });
    }
    
    Ok(Data::new(parsed))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="early-returns"><a class="header" href="#early-returns">Early Returns</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Idiomatic: Early return with ?
fn process(input: &amp;str) -&gt; Result&lt;String&gt; {
    let trimmed = input.trim();
    
    if trimmed.is_empty() {
        return Err(Error::EmptyInput);
    }
    
    let parsed = trimmed.parse::&lt;i32&gt;()?;
    let validated = validate(parsed)?;
    let result = compute(validated)?;
    
    Ok(format!("Result: {}", result))
}

// Not idiomatic: Nested error handling
fn process_nested(input: &amp;str) -&gt; Result&lt;String&gt; {
    match input.trim() {
        trimmed if !trimmed.is_empty() =&gt; {
            match trimmed.parse::&lt;i32&gt;() {
                Ok(parsed) =&gt; {
                    match validate(parsed) {
                        Ok(validated) =&gt; {
                            match compute(validated) {
                                Ok(result) =&gt; Ok(format!("Result: {}", result)),
                                Err(e) =&gt; Err(e),
                            }
                        }
                        Err(e) =&gt; Err(e),
                    }
                }
                Err(e) =&gt; Err(e.into()),
            }
        }
        _ =&gt; Err(Error::EmptyInput),
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="iterator-patterns"><a class="header" href="#iterator-patterns">Iterator Patterns</a></h2>
<h3 id="lazy-evaluation-and-chaining"><a class="header" href="#lazy-evaluation-and-chaining">Lazy Evaluation and Chaining</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Idiomatic: Iterator chains
fn process_data(items: &amp;[Item]) -&gt; Vec&lt;Summary&gt; {
    items.iter()
        .filter(|item| item.is_valid())
        .filter_map(|item| item.try_process())
        .map(|processed| Summary::from(processed))
        .collect()
}

// Not idiomatic: Manual loops
fn process_data_manual(items: &amp;[Item]) -&gt; Vec&lt;Summary&gt; {
    let mut result = Vec::new();
    for item in items {
        if item.is_valid() {
            if let Some(processed) = item.try_process() {
                result.push(Summary::from(processed));
            }
        }
    }
    result
}
<span class="boring">}</span></code></pre></pre>
<h3 id="custom-iterators"><a class="header" href="#custom-iterators">Custom Iterators</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Idiomatic custom iterator
struct Fibonacci {
    curr: u64,
    next: u64,
}

impl Fibonacci {
    fn new() -&gt; Self {
        Fibonacci { curr: 0, next: 1 }
    }
}

impl Iterator for Fibonacci {
    type Item = u64;
    
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let current = self.curr;
        self.curr = self.next;
        self.next = current + self.next;
        Some(current)
    }
}

// Usage
let fib_numbers: Vec&lt;u64&gt; = Fibonacci::new()
    .take(10)
    .collect();
<span class="boring">}</span></code></pre></pre>
<h2 id="api-design-patterns"><a class="header" href="#api-design-patterns">API Design Patterns</a></h2>
<h3 id="taking-strings"><a class="header" href="#taking-strings">Taking Strings</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Idiomatic: Accept anything string-like
fn greet(name: impl AsRef&lt;str&gt;) {
    println!("Hello, {}!", name.as_ref());
}

// Or for storing:
struct Person {
    name: String,
}

impl Person {
    // Accept anything that can become a String
    fn new(name: impl Into&lt;String&gt;) -&gt; Self {
        Person { name: name.into() }
    }
}

// Usage - all work:
greet("Alice");
greet(String::from("Bob"));
greet(&amp;some_string);

let p1 = Person::new("Charlie");
let p2 = Person::new(String::from("David"));
<span class="boring">}</span></code></pre></pre>
<h3 id="returning-iterators"><a class="header" href="#returning-iterators">Returning Iterators</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Idiomatic: Return impl Iterator for flexibility
fn get_even_numbers(max: u32) -&gt; impl Iterator&lt;Item = u32&gt; {
    (0..=max).filter(|n| n % 2 == 0)
}

// For more complex cases:
struct DataProcessor;

impl DataProcessor {
    fn process&lt;'a&gt;(&amp;'a self, items: &amp;'a [Item]) 
        -&gt; impl Iterator&lt;Item = ProcessedItem&gt; + 'a {
        items.iter()
            .filter(|item| self.should_process(item))
            .map(move |item| self.transform(item))
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="optional-parameters"><a class="header" href="#optional-parameters">Optional Parameters</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Idiomatic: Use Option for optional parameters
#[derive(Default)]
struct QueryOptions {
    limit: Option&lt;usize&gt;,
    offset: Option&lt;usize&gt;,
    sort_by: Option&lt;String&gt;,
}

fn query_database(options: QueryOptions) -&gt; Result&lt;Vec&lt;Record&gt;&gt; {
    let limit = options.limit.unwrap_or(100);
    let offset = options.offset.unwrap_or(0);
    // ...
}

// Usage
query_database(QueryOptions {
    limit: Some(50),
    ..Default::default()
})?;
<span class="boring">}</span></code></pre></pre>
<h2 id="type-system-patterns"><a class="header" href="#type-system-patterns">Type System Patterns</a></h2>
<h3 id="type-state-pattern"><a class="header" href="#type-state-pattern">Type State Pattern</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Encode state in the type system
struct Locked;
struct Unlocked;

struct Safe&lt;State = Locked&gt; {
    treasure: String,
    _state: PhantomData&lt;State&gt;,
}

impl Safe&lt;Locked&gt; {
    fn unlock(self, combination: &amp;str) -&gt; Result&lt;Safe&lt;Unlocked&gt;, Safe&lt;Locked&gt;&gt; {
        if combination == "12345" {
            Ok(Safe {
                treasure: self.treasure,
                _state: PhantomData,
            })
        } else {
            Err(self)
        }
    }
}

impl Safe&lt;Unlocked&gt; {
    fn get_treasure(&amp;self) -&gt; &amp;str {
        &amp;self.treasure
    }
    
    fn lock(self) -&gt; Safe&lt;Locked&gt; {
        Safe {
            treasure: self.treasure,
            _state: PhantomData,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="extension-traits"><a class="header" href="#extension-traits">Extension Traits</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Idiomatic: Add methods to foreign types
trait VecExt&lt;T&gt; {
    fn get_or_insert(&amp;mut self, index: usize, default: T) -&gt; &amp;mut T;
}

impl&lt;T&gt; VecExt&lt;T&gt; for Vec&lt;T&gt; {
    fn get_or_insert(&amp;mut self, index: usize, default: T) -&gt; &amp;mut T {
        if index &gt;= self.len() {
            self.resize_with(index + 1, || default);
        }
        &amp;mut self[index]
    }
}

// Usage
let mut vec = vec![1, 2, 3];
*vec.get_or_insert(5, 0) = 42;
<span class="boring">}</span></code></pre></pre>
<h2 id="conversion-patterns"><a class="header" href="#conversion-patterns">Conversion Patterns</a></h2>
<h3 id="from-and-into"><a class="header" href="#from-and-into">From and Into</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Idiomatic conversions
#[derive(Debug)]
struct Email(String);

impl From&lt;String&gt; for Email {
    fn from(s: String) -&gt; Self {
        Email(s)
    }
}

impl From&lt;&amp;str&gt; for Email {
    fn from(s: &amp;str) -&gt; Self {
        Email(s.to_string())
    }
}

// Automatically get Into
fn send_email(email: impl Into&lt;Email&gt;) {
    let email = email.into();
    // ...
}

// Usage
send_email("alice@example.com");
send_email(String::from("bob@example.com"));
<span class="boring">}</span></code></pre></pre>
<h3 id="tryfrom-for-fallible-conversions"><a class="header" href="#tryfrom-for-fallible-conversions">TryFrom for Fallible Conversions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::convert::TryFrom;

struct PositiveInteger(i32);

impl TryFrom&lt;i32&gt; for PositiveInteger {
    type Error = &amp;'static str;
    
    fn try_from(value: i32) -&gt; Result&lt;Self, Self::Error&gt; {
        if value &gt; 0 {
            Ok(PositiveInteger(value))
        } else {
            Err("Value must be positive")
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="common-anti-patterns-to-avoid"><a class="header" href="#common-anti-patterns-to-avoid">Common Anti-Patterns to Avoid</a></h2>
<h3 id="1-unnecessary-cloning"><a class="header" href="#1-unnecessary-cloning">1. Unnecessary Cloning</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Bad: Cloning when borrowing would work
fn bad(data: Vec&lt;String&gt;) -&gt; String {
    let cloned = data.clone();  // Unnecessary!
    process(&amp;cloned)
}

// Good: Borrow instead
fn good(data: &amp;[String]) -&gt; String {
    process(data)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-stringly-typed-apis"><a class="header" href="#2-stringly-typed-apis">2. Stringly-Typed APIs</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Bad: Using strings for everything
fn set_status(status: &amp;str) {
    match status {
        "active" =&gt; { /* ... */ }
        "inactive" =&gt; { /* ... */ }
        _ =&gt; panic!("Invalid status"),
    }
}

// Good: Use enums
enum Status {
    Active,
    Inactive,
}

fn set_status(status: Status) {
    match status {
        Status::Active =&gt; { /* ... */ }
        Status::Inactive =&gt; { /* ... */ }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-nested-optionsresults"><a class="header" href="#3-nested-optionsresults">3. Nested Options/Results</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Bad: Option&lt;Option&lt;T&gt;&gt; or Result&lt;Result&lt;T, E&gt;, E&gt;
fn bad() -&gt; Option&lt;Option&lt;Data&gt;&gt; {
    // ...
}

// Good: Flatten or use custom type
fn good() -&gt; Option&lt;Data&gt; {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="rust-vs-cnet-patterns"><a class="header" href="#rust-vs-cnet-patterns">Rust vs C++/.NET Patterns</a></h2>
<h3 id="resource-management"><a class="header" href="#resource-management">Resource Management</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Pattern</th><th>C++</th><th>.NET</th><th>Rust</th></tr></thead><tbody>
<tr><td>Resource cleanup</td><td>Destructor</td><td>IDisposable/using</td><td>Drop trait</td></tr>
<tr><td>Shared ownership</td><td>shared_ptr</td><td>Reference counting</td><td>Rc/Arc</td></tr>
<tr><td>Weak references</td><td>weak_ptr</td><td>WeakReference</td><td>Weak</td></tr>
<tr><td>Move semantics</td><td>Move constructor</td><td>N/A</td><td>Default behavior</td></tr>
</tbody></table>
</div>
<h3 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Pattern</th><th>C++</th><th>.NET</th><th>Rust</th></tr></thead><tbody>
<tr><td>Error propagation</td><td>Exceptions/error codes</td><td>Exceptions</td><td>Result + ?</td></tr>
<tr><td>Null handling</td><td>nullptr checks</td><td>null checks/nullable</td><td>Option<T></td></tr>
<tr><td>Assertions</td><td>assert macro</td><td>Debug.Assert</td><td>debug_assert!</td></tr>
</tbody></table>
</div>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<h3 id="exercise-261-refactor-to-idiomatic"><a class="header" href="#exercise-261-refactor-to-idiomatic">Exercise 26.1: Refactor to Idiomatic</a></h3>
<p>Refactor this code to be more idiomatic:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn process_items(items: Vec&lt;Item&gt;) -&gt; Vec&lt;String&gt; {
    let mut results = Vec::new();
    for i in 0..items.len() {
        if items[i].is_valid == true {
            let processed = items[i].process();
            results.push(processed);
        }
    }
    return results;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="exercise-262-design-an-api"><a class="header" href="#exercise-262-design-an-api">Exercise 26.2: Design an API</a></h3>
<p>Design an idiomatic Rust API for a configuration system that:</p>
<ul>
<li>Loads from multiple sources (file, env, args)</li>
<li>Validates configuration</li>
<li>Provides typed access to values</li>
</ul>
<h3 id="exercise-263-pattern-recognition"><a class="header" href="#exercise-263-pattern-recognition">Exercise 26.3: Pattern Recognition</a></h3>
<p>Identify the patterns used in this code and explain why they're idiomatic:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn read_lines&lt;P&gt;(filename: P) -&gt; io::Result&lt;io::Lines&lt;io::BufReader&lt;File&gt;&gt;&gt;
where
    P: AsRef&lt;Path&gt;,
{
    let file = File::open(filename)?;
    Ok(io::BufReader::new(file).lines())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways</a></h2>
<p>✅ <strong>Embrace ownership</strong> - Make ownership transfers explicit and clear</p>
<p>✅ <strong>Use the type system</strong> - Encode invariants in types, not runtime checks</p>
<p>✅ <strong>Prefer composition</strong> - Traits and generics over inheritance</p>
<p>✅ <strong>Early returns with ?</strong> - Linear error handling, not nested</p>
<p>✅ <strong>Iterator chains</strong> - Functional style for data transformation</p>
<p>✅ <strong>Zero-cost abstractions</strong> - High-level code with no runtime penalty</p>
<p>✅ <strong>Explicit over implicit</strong> - Make intentions clear in the code</p>
<hr />
<p>This completes your Rust journey from C++/.NET. Welcome to the Rust community! 🦀</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../transfer/26_performance.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../transfer/26_performance.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
