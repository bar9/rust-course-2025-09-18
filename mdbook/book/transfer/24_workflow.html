<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Axum Web Services - From ASP.NET to Type-Safe APIs</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-24-axum-web-services---from-aspnet-to-type-safe-apis"><a class="header" href="#chapter-24-axum-web-services---from-aspnet-to-type-safe-apis">Chapter 24: Axum Web Services - From ASP.NET to Type-Safe APIs</a></h1>
<h2 id="building-high-performance-web-services-with-axum"><a class="header" href="#building-high-performance-web-services-with-axum">Building High-Performance Web Services with Axum</a></h2>
<h3 id="web-framework-comparison"><a class="header" href="#web-framework-comparison">Web Framework Comparison</a></h3>
<p>Axum brings type safety and performance to web development, contrasting with other frameworks:</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>ASP.NET Core</th><th>C++ (Crow/Drogon)</th><th>Axum</th></tr></thead><tbody>
<tr><td><strong>Type Safety</strong></td><td>Runtime validation</td><td>Manual type handling</td><td>Compile-time guarantees</td></tr>
<tr><td><strong>Performance</strong></td><td>Good</td><td>Excellent</td><td>Excellent</td></tr>
<tr><td><strong>Async Support</strong></td><td>Built-in</td><td>Manual/callbacks</td><td>Native async/await</td></tr>
<tr><td><strong>Middleware</strong></td><td>Pipeline-based</td><td>Manual composition</td><td>Tower layers</td></tr>
<tr><td><strong>Dependency Injection</strong></td><td>Built-in container</td><td>Manual</td><td>Type system</td></tr>
<tr><td><strong>Route Safety</strong></td><td>String-based</td><td>String-based</td><td>Type-safe extractors</td></tr>
</tbody></table>
</div>
<h3 id="key-advantages-of-axum"><a class="header" href="#key-advantages-of-axum">Key Advantages of Axum</a></h3>
<ol>
<li><strong>Zero-cost abstractions</strong> - No runtime overhead for type safety</li>
<li><strong>Composable middleware</strong> - Tower ecosystem integration</li>
<li><strong>Type-safe extractors</strong> - Request data validated at compile time</li>
<li><strong>Excellent performance</strong> - Built on hyper and tokio</li>
<li><strong>Interoperability</strong> - Works seamlessly with existing Rust ecosystem</li>
</ol>
<hr />
<h2 id="axum-fundamentals---building-the-esp32-c3-coordinator-api"><a class="header" href="#axum-fundamentals---building-the-esp32-c3-coordinator-api">Axum Fundamentals - Building the ESP32-C3 Coordinator API</a></h2>
<h3 id="basic-axum-setup-for-iot-data-collection"><a class="header" href="#basic-axum-setup-for-iot-data-collection">Basic Axum Setup for IoT Data Collection</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Cargo.toml dependencies
use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    response::{IntoResponse, Json},
    routing::{get, post},
    Router,
};
        }
    }
    
    // Try to use data again - compiler error!
    println!("Processed {} items", data.len());  // ❌ Moved value
    
    results
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-read-compiler-messages-theyre-helpful"><a class="header" href="#2-read-compiler-messages-theyre-helpful">2. Read Compiler Messages (They're Helpful!)</a></h3>
<pre><code>error[E0382]: borrow of moved value: `data`
  --&gt; src/main.rs:9:37
   |
2  | fn process_data(data: Vec&lt;String&gt;) -&gt; Vec&lt;String&gt; {
   |                 ---- move occurs because `data` has type `Vec&lt;String&gt;`, which does not implement the `Copy` trait
3  |     let mut results = Vec::new();
4  |     
5  |     for item in data {
   |                 ---- `data` moved due to this implicit call to `.into_iter()`
...
9  |     println!("Processed {} items", data.len());
   |                                     ^^^^ value borrowed here after move
   |
help: consider iterating over a slice of the `Vec&lt;String&gt;`'s content to avoid moving into the for loop
   |
5  |     for item in &amp;data {
   |                 +
</code></pre>
<h3 id="3-follow-compiler-suggestions"><a class="header" href="#3-follow-compiler-suggestions">3. Follow Compiler Suggestions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Fixed version following compiler advice
fn process_data(data: Vec&lt;String&gt;) -&gt; Vec&lt;String&gt; {
    let mut results = Vec::new();
    
    // Borrow instead of move
    for item in &amp;data {  // ✅ Compiler suggested this
        if item.len() &gt; 0 {
            results.push(item.to_uppercase());
        }
    }
    
    println!("Processed {} items", data.len());  // ✅ Now works
    
    results
}
<span class="boring">}</span></code></pre></pre>
<h3 id="4-iterate-until-compiler-is-happy"><a class="header" href="#4-iterate-until-compiler-is-happy">4. Iterate Until Compiler is Happy</a></h3>
<p>The Rust motto: <strong>"If it compiles, it probably works correctly."</strong></p>
<hr />
<h2 id="ide-integration-and-tooling"><a class="header" href="#ide-integration-and-tooling">IDE Integration and Tooling</a></h2>
<h3 id="rust-analyzer-the-game-changer"><a class="header" href="#rust-analyzer-the-game-changer">Rust Analyzer (The Game Changer)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Hover over any variable to see its type
let data = vec![1, 2, 3];  // rust-analyzer shows: Vec&lt;i32&gt;

// Inline error messages as you type
let x = 5;
let y = "hello";
let z = x + y;  // ❌ Error shown immediately: cannot add integer to string

// Auto-completion with type information
// Type 'data.' and see all available methods with documentation
<span class="boring">}</span></code></pre></pre>
<h3 id="cargo-more-than-a-build-tool"><a class="header" href="#cargo-more-than-a-build-tool">Cargo: More Than a Build Tool</a></h3>
<pre><code class="language-bash"># Create new project
cargo new my_project
cd my_project

# Add dependencies
cargo add serde --features derive
cargo add tokio --features full

# Build with different profiles
cargo build              # Debug build
cargo build --release    # Optimized build
cargo check              # Fast syntax check, no executable

# Testing
cargo test               # Run all tests
cargo test integration   # Run specific tests
cargo bench             # Run benchmarks

# Code quality
cargo clippy            # Linter with suggestions
cargo fmt               # Format code consistently
cargo audit             # Security vulnerability check

# Documentation
cargo doc --open        # Generate and open docs
</code></pre>
<hr />
<h2 id="error-driven-development"><a class="header" href="#error-driven-development">Error-Driven Development</a></h2>
<h3 id="embrace-the-red-squiggles"><a class="header" href="#embrace-the-red-squiggles">Embrace the Red Squiggles</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Start with the simplest version that doesn't compile
struct User {
    name: String,
    email: String,
}

fn create_user() -&gt; User {
    // This won't compile - missing fields
    User {}  // ❌ Compiler tells you what's missing
}

// Compiler error guides you:
// error: missing fields `name` and `email` in initializer of `User`

// Fix step by step
fn create_user() -&gt; User {
    User {
        name: String::from("Alice"),
        email: String::from("alice@example.com"),
    }  // ✅ Now compiles
}
<span class="boring">}</span></code></pre></pre>
<h3 id="let-the-compiler-teach-you"><a class="header" href="#let-the-compiler-teach-you">Let the Compiler Teach You</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Compiler teaches you about lifetimes
fn get_first_word(s: &amp;str) -&gt; &amp;str {
    let words: Vec&lt;&amp;str&gt; = s.split_whitespace().collect();
    words[0]  // ❌ Compiler explains lifetime issue
}

// After reading the error, you learn:
fn get_first_word(s: &amp;str) -&gt; &amp;str {
    s.split_whitespace().next().unwrap_or("")  // ✅ Better solution
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="testing-strategy"><a class="header" href="#testing-strategy">Testing Strategy</a></h2>
<h3 id="tests-that-actually-catch-bugs"><a class="header" href="#tests-that-actually-catch-bugs">Tests That Actually Catch Bugs</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In C++/C#, tests often focus on happy paths
// In Rust, the compiler catches many edge cases

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_edge_cases_compiler_cant_catch() {
        // Focus on business logic, not null pointer exceptions
        let result = calculate_discount(100.0, 0.1);
        assert_eq!(result, 90.0);
        
        // Test error conditions
        let result = divide_numbers(10.0, 0.0);
        assert!(result.is_err());
    }
    
    #[test]
    fn test_with_sample_data() {
        // Property-based testing is popular in Rust
        for i in 0..1000 {
            let result = my_function(i);
            assert!(result &gt;= 0);  // Invariant holds
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="integration-testing"><a class="header" href="#integration-testing">Integration Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// tests/integration_test.rs
use my_crate::*;

#[test]
fn test_full_workflow() {
    let mut service = MyService::new();
    service.configure("test_config.toml").unwrap();
    
    let result = service.process_request(Request::new("test"))
        .expect("Processing should succeed");
        
    assert_eq!(result.status, Status::Success);
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="performance-first-development"><a class="header" href="#performance-first-development">Performance-First Development</a></h2>
<h3 id="profile-guided-development"><a class="header" href="#profile-guided-development">Profile-Guided Development</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Write clean code first, optimize later
fn process_items(items: &amp;[Item]) -&gt; Vec&lt;ProcessedItem&gt; {
    items.iter()
        .filter(|item| item.is_valid())
        .map(|item| item.process())
        .collect()
}

// Profile with cargo flamegraph
// cargo install flamegraph
// sudo cargo flamegraph

// Optimize hot paths
fn process_items_optimized(items: &amp;[Item]) -&gt; Vec&lt;ProcessedItem&gt; {
    let mut results = Vec::with_capacity(items.len());  // Pre-allocate
    
    for item in items {
        if item.is_valid() {
            results.push(item.process());
        }
    }
    
    results
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="refactoring-confidence"><a class="header" href="#refactoring-confidence">Refactoring Confidence</a></h2>
<h3 id="fearless-refactoring"><a class="header" href="#fearless-refactoring">Fearless Refactoring</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Change function signature
fn old_function(data: String) -&gt; String {
    data.to_uppercase()
}

// Refactor to be more efficient
fn new_function(data: &amp;str) -&gt; String {  // Take &amp;str instead of String
    data.to_uppercase()
}

// Compiler will show you EVERY place that needs updating
// No silent runtime failures
// No "works on my machine" issues
<span class="boring">}</span></code></pre></pre>
<h3 id="extract-functions-safely"><a class="header" href="#extract-functions-safely">Extract Functions Safely</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Extract complex logic into separate functions
fn complex_calculation(a: f64, b: f64, c: f64) -&gt; f64 {
    let intermediate = calculate_intermediate(a, b);
    apply_correction(intermediate, c)
}

fn calculate_intermediate(a: f64, b: f64) -&gt; f64 {
    // Extracted logic
    a * b + b.sqrt()
}

fn apply_correction(value: f64, correction: f64) -&gt; f64 {
    // More extracted logic
    value * correction.sin()
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="debugging-in-rust"><a class="header" href="#debugging-in-rust">Debugging in Rust</a></h2>
<h3 id="less-debugging-more-logic-errors"><a class="header" href="#less-debugging-more-logic-errors">Less Debugging, More Logic Errors</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Most "debugging" is actually logic errors, not crashes
fn find_user_by_email(users: &amp;[User], email: &amp;str) -&gt; Option&lt;&amp;User&gt; {
    users.iter().find(|user| user.email == email)
}

// Debug by adding prints or using debugger
fn debug_search(users: &amp;[User], email: &amp;str) -&gt; Option&lt;&amp;User&gt; {
    println!("Searching for email: {}", email);
    println!("Have {} users to search", users.len());
    
    let result = users.iter().find(|user| {
        println!("Checking user: {}", user.email);
        user.email == email
    });
    
    match result {
        Some(user) =&gt; println!("Found user: {}", user.name),
        None =&gt; println!("User not found"),
    }
    
    result
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways</a></h2>
<ol>
<li><strong>The compiler is your friend</strong> - trust its guidance</li>
<li><strong>Red squiggles are good</strong> - they prevent runtime bugs</li>
<li><strong>Iterate quickly</strong> - cargo check is very fast</li>
<li><strong>Read error messages carefully</strong> - they're usually helpful</li>
<li><strong>Use rust-analyzer</strong> - it makes development much smoother</li>
<li><strong>Test business logic</strong> - let the compiler handle safety</li>
<li><strong>Profile before optimizing</strong> - but know that Rust is fast by default</li>
</ol>
<h3 id="mindset-shift"><a class="header" href="#mindset-shift">Mindset Shift</a></h3>
<ul>
<li><strong>C++</strong>: "I hope this doesn't crash"</li>
<li><strong>C#</strong>: "I hope the GC doesn't pause at a bad time"</li>
<li><strong>Rust</strong>: "If it compiles, I'm confident it works"</li>
</ul>
<p>The result is higher confidence, fewer bugs in production, and more time spent on solving business problems instead of chasing memory errors.</p>
<p><strong>This workflow fundamentally changes how you approach software development - from reactive debugging to proactive correctness.</strong></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../transfer/23_traits_vs_oop.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../transfer/25_unsafe_ffi.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../transfer/23_traits_vs_oop.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../transfer/25_unsafe_ffi.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
