<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Unsafe Rust &amp; FFI</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-25-unsafe-rust--ffi"><a class="header" href="#chapter-25-unsafe-rust--ffi">Chapter 25: Unsafe Rust &amp; FFI</a></h1>
<h2 id="learning-objectives"><a class="header" href="#learning-objectives">Learning Objectives</a></h2>
<ul>
<li>Understand when and why to use unsafe Rust</li>
<li>Learn to interface with C/C++ code</li>
<li>Master bindgen for automatic bindings</li>
<li>Establish safety contracts and invariants</li>
<li>Wrap unsafe code in safe abstractions</li>
</ul>
<h2 id="when-unsafe-is-necessary"><a class="header" href="#when-unsafe-is-necessary">When Unsafe is Necessary</a></h2>
<p>Unsafe Rust allows you to:</p>
<ol>
<li>Dereference raw pointers</li>
<li>Call unsafe functions</li>
<li>Access or modify mutable static variables</li>
<li>Implement unsafe traits</li>
<li>Access fields of unions</li>
</ol>
<h3 id="common-use-cases"><a class="header" href="#common-use-cases">Common Use Cases</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 1. Interfacing with C libraries
extern "C" {
    fn strlen(s: *const c_char) -&gt; size_t;
}

// 2. Performance-critical code
unsafe fn fast_copy&lt;T&gt;(src: *const T, dst: *mut T, count: usize) {
    std::ptr::copy_nonoverlapping(src, dst, count);
}

// 3. Implementing fundamental abstractions
struct MyVec&lt;T&gt; {
    ptr: *mut T,
    len: usize,
    capacity: usize,
}

// 4. Hardware interaction
unsafe fn read_sensor() -&gt; u32 {
    std::ptr::read_volatile(0x4000_0000 as *const u32)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="raw-pointers"><a class="header" href="#raw-pointers">Raw Pointers</a></h2>
<h3 id="creating-and-using-raw-pointers"><a class="header" href="#creating-and-using-raw-pointers">Creating and Using Raw Pointers</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn raw_pointer_example() {
    let mut num = 5;
    
    // Create raw pointers
    let r1 = &amp;num as *const i32;
    let r2 = &amp;mut num as *mut i32;
    
    // Can create raw pointers in safe code
    // But dereferencing requires unsafe
    unsafe {
        println!("r1: {}", *r1);
        *r2 = 10;
        println!("r2: {}", *r2);
    }
    
    // Raw pointers can be null
    let null_ptr: *const i32 = std::ptr::null();
    
    // Check before dereferencing
    unsafe {
        if !null_ptr.is_null() {
            println!("Value: {}", *null_ptr);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="pointer-arithmetic"><a class="header" href="#pointer-arithmetic">Pointer Arithmetic</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn pointer_arithmetic() {
    let arr = [1, 2, 3, 4, 5];
    let ptr = arr.as_ptr();
    
    // Pointer arithmetic
    let second = ptr.add(1);
    let last = ptr.add(arr.len() - 1);
    
    println!("Second: {}", *second); // 2
    println!("Last: {}", *last);     // 5
    
    // Iterate using raw pointers
    let mut current = ptr;
    let end = ptr.add(arr.len());
    
    while current &lt; end {
        println!("Value: {}", *current);
        current = current.add(1);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="ffi-with-c"><a class="header" href="#ffi-with-c">FFI with C</a></h2>
<h3 id="basic-c-function-binding"><a class="header" href="#basic-c-function-binding">Basic C Function Binding</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::os::raw::{c_char, c_int};
use std::ffi::{CString, CStr};

// Declare external C functions
extern "C" {
    fn printf(format: *const c_char, ...) -&gt; c_int;
    fn sqrt(x: f64) -&gt; f64;
    fn abs(x: c_int) -&gt; c_int;
}

fn call_c_functions() {
    unsafe {
        // Call C math functions
        let result = sqrt(16.0);
        println!("sqrt(16) = {}", result);
        
        let absolute = abs(-42);
        println!("abs(-42) = {}", absolute);
        
        // Call printf (variadic function)
        let format = CString::new("Hello from Rust: %d\n").unwrap();
        printf(format.as_ptr(), 42);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="calling-rust-from-c"><a class="header" href="#calling-rust-from-c">Calling Rust from C</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Make Rust functions callable from C
#[no_mangle]
pub extern "C" fn rust_function(x: i32) -&gt; i32 {
    x * 2
}

#[no_mangle]
pub extern "C" fn rust_string_length(s: *const c_char) -&gt; usize {
    unsafe {
        if s.is_null() {
            return 0;
        }
        CStr::from_ptr(s).to_bytes().len()
    }
}

// Prevent name mangling for structs
#[repr(C)]
pub struct Point {
    x: f64,
    y: f64,
}

#[no_mangle]
pub extern "C" fn create_point(x: f64, y: f64) -&gt; Point {
    Point { x, y }
}

#[no_mangle]
pub extern "C" fn distance(p1: &amp;Point, p2: &amp;Point) -&gt; f64 {
    ((p2.x - p1.x).powi(2) + (p2.y - p1.y).powi(2)).sqrt()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="ffi-with-c-1"><a class="header" href="#ffi-with-c-1">FFI with C++</a></h2>
<h3 id="c-interop-challenges"><a class="header" href="#c-interop-challenges">C++ Interop Challenges</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// C++ has name mangling, classes, templates
// Usually need extern "C" wrapper in C++

// wrapper.hpp
<span class="boring">ifdef __cplusplus
</span>extern "C" {
<span class="boring">endif
</span>
typedef struct {
    double x;
    double y;
} Point;

Point* create_point_cpp(double x, double y);
void delete_point_cpp(Point* p);
double calculate_distance_cpp(const Point* p1, const Point* p2);

<span class="boring">ifdef __cplusplus
</span>}
<span class="boring">endif
</span>
// Rust bindings
extern "C" {
    fn create_point_cpp(x: f64, y: f64) -&gt; *mut Point;
    fn delete_point_cpp(p: *mut Point);
    fn calculate_distance_cpp(p1: *const Point, p2: *const Point) -&gt; f64;
}

// Safe wrapper
pub struct CppPoint {
    ptr: *mut Point,
}

impl CppPoint {
    pub fn new(x: f64, y: f64) -&gt; Self {
        unsafe {
            CppPoint {
                ptr: create_point_cpp(x, y),
            }
        }
    }
    
    pub fn distance(&amp;self, other: &amp;CppPoint) -&gt; f64 {
        unsafe {
            calculate_distance_cpp(self.ptr, other.ptr)
        }
    }
}

impl Drop for CppPoint {
    fn drop(&amp;mut self) {
        unsafe {
            delete_point_cpp(self.ptr);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="using-bindgen"><a class="header" href="#using-bindgen">Using Bindgen</a></h2>
<h3 id="setup-and-configuration"><a class="header" href="#setup-and-configuration">Setup and Configuration</a></h3>
<pre><code class="language-toml"># Cargo.toml
[build-dependencies]
bindgen = "0.69"

[dependencies]
libc = "0.2"
</code></pre>
<h3 id="build-script"><a class="header" href="#build-script">Build Script</a></h3>
<pre><pre class="playground"><code class="language-rust">// build.rs
use bindgen;
use std::env;
use std::path::PathBuf;

fn main() {
    // Tell cargo to link the system library
    println!("cargo:rustc-link-lib=mylib");
    println!("cargo:rerun-if-changed=wrapper.h");
    
    // Generate bindings
    let bindings = bindgen::Builder::default()
        .header("wrapper.h")
        .parse_callbacks(Box::new(bindgen::CargoCallbacks))
        .generate()
        .expect("Unable to generate bindings");
    
    // Write bindings to file
    let out_path = PathBuf::from(env::var("OUT_DIR").unwrap());
    bindings
        .write_to_file(out_path.join("bindings.rs"))
        .expect("Couldn't write bindings!");
}</code></pre></pre>
<h3 id="using-generated-bindings"><a class="header" href="#using-generated-bindings">Using Generated Bindings</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/lib.rs
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

include!(concat!(env!("OUT_DIR"), "/bindings.rs"));

// Safe wrapper around generated unsafe bindings
pub struct SafeWrapper {
    handle: *mut GeneratedStruct,
}

impl SafeWrapper {
    pub fn new() -&gt; Option&lt;Self&gt; {
        unsafe {
            let handle = generated_create();
            if handle.is_null() {
                None
            } else {
                Some(SafeWrapper { handle })
            }
        }
    }
    
    pub fn process(&amp;mut self, data: &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
        unsafe {
            let result = generated_process(
                self.handle,
                data.as_ptr(),
                data.len()
            );
            
            if result.is_null() {
                Err("Processing failed".to_string())
            } else {
                // Convert result to Vec&lt;u8&gt;
                let len = generated_result_length(result);
                let slice = std::slice::from_raw_parts(
                    result as *const u8,
                    len
                );
                let vec = slice.to_vec();
                generated_free_result(result);
                Ok(vec)
            }
        }
    }
}

impl Drop for SafeWrapper {
    fn drop(&amp;mut self) {
        unsafe {
            generated_destroy(self.handle);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="safety-contracts"><a class="header" href="#safety-contracts">Safety Contracts</a></h2>
<h3 id="establishing-invariants"><a class="header" href="#establishing-invariants">Establishing Invariants</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// SAFETY: This struct maintains the following invariants:
/// 1. `ptr` is always valid and points to `capacity` elements
/// 2. `len &lt;= capacity`
/// 3. Elements 0..len are initialized
/// 4. The allocator used is the global allocator
pub struct SafeVec&lt;T&gt; {
    ptr: *mut T,
    len: usize,
    capacity: usize,
}

impl&lt;T&gt; SafeVec&lt;T&gt; {
    /// Creates a new empty vector
    /// 
    /// # Safety
    /// This function is safe because it maintains all invariants
    pub fn new() -&gt; Self {
        SafeVec {
            ptr: std::ptr::null_mut(),
            len: 0,
            capacity: 0,
        }
    }
    
    /// Pushes an element onto the vector
    /// 
    /// # Safety
    /// Safe because:
    /// - Allocation is handled properly
    /// - Capacity is checked and grown if needed
    /// - Length is updated after successful write
    pub fn push(&amp;mut self, value: T) {
        if self.len == self.capacity {
            self.grow();
        }
        
        unsafe {
            // SAFETY: We just ensured capacity &gt; len
            std::ptr::write(self.ptr.add(self.len), value);
            self.len += 1;
        }
    }
    
    fn grow(&amp;mut self) {
        // Implementation maintaining invariants
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="unsafe-trait-implementation"><a class="header" href="#unsafe-trait-implementation">Unsafe Trait Implementation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Marker traits that affect compiler behavior
unsafe impl&lt;T: Send&gt; Send for SafeVec&lt;T&gt; {}
unsafe impl&lt;T: Sync&gt; Sync for SafeVec&lt;T&gt; {}

// SAFETY: We only implement Send if T is Send
// because our vector owns T values
<span class="boring">}</span></code></pre></pre>
<h2 id="common-undefined-behaviors-to-avoid"><a class="header" href="#common-undefined-behaviors-to-avoid">Common Undefined Behaviors to Avoid</a></h2>
<h3 id="1-data-races"><a class="header" href="#1-data-races">1. Data Races</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// WRONG: Data race
static mut COUNTER: i32 = 0;

fn bad_increment() {
    unsafe {
        COUNTER += 1; // Data race if called from multiple threads
    }
}

// CORRECT: Use synchronization
use std::sync::atomic::{AtomicI32, Ordering};
static COUNTER: AtomicI32 = AtomicI32::new(0);

fn good_increment() {
    COUNTER.fetch_add(1, Ordering::SeqCst);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-invalid-memory-access"><a class="header" href="#2-invalid-memory-access">2. Invalid Memory Access</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// WRONG: Use after free
fn bad_pointer() -&gt; *const i32 {
    let x = 42;
    &amp;x as *const i32 // x is dropped, pointer becomes invalid
}

// CORRECT: Ensure lifetime
fn good_pointer(x: &amp;i32) -&gt; *const i32 {
    x as *const i32 // Pointer valid as long as reference is
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-aliasing-violations"><a class="header" href="#3-aliasing-violations">3. Aliasing Violations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// WRONG: Mutable aliasing
fn bad_aliasing() {
    let mut x = 5;
    let r1 = &amp;mut x as *mut i32;
    let r2 = &amp;mut x as *mut i32;
    unsafe {
        *r1 = 10;
        *r2 = 20; // Undefined behavior: two mutable aliases
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="1-minimize-unsafe-scope"><a class="header" href="#1-minimize-unsafe-scope">1. Minimize Unsafe Scope</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Bad: Large unsafe block
unsafe {
    let ptr = allocate_memory();
    initialize_data(ptr);
    process_data(ptr);
    cleanup(ptr);
}

// Good: Multiple small unsafe blocks
let ptr = unsafe { allocate_memory() };
unsafe { initialize_data(ptr); }
unsafe { process_data(ptr); }
unsafe { cleanup(ptr); }
<span class="boring">}</span></code></pre></pre>
<h3 id="2-document-safety-requirements"><a class="header" href="#2-document-safety-requirements">2. Document Safety Requirements</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Copies `count` elements from `src` to `dst`
/// 
/// # Safety
/// 
/// - `src` must be valid for reads of `count * size_of::&lt;T&gt;()` bytes
/// - `dst` must be valid for writes of `count * size_of::&lt;T&gt;()` bytes
/// - The regions must not overlap
pub unsafe fn copy_memory&lt;T&gt;(src: *const T, dst: *mut T, count: usize) {
    std::ptr::copy_nonoverlapping(src, dst, count);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-provide-safe-abstractions"><a class="header" href="#3-provide-safe-abstractions">3. Provide Safe Abstractions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct FfiString {
    ptr: *mut c_char,
}

impl FfiString {
    pub fn new(s: &amp;str) -&gt; Result&lt;Self, std::ffi::NulError&gt; {
        let c_string = CString::new(s)?;
        Ok(FfiString {
            ptr: c_string.into_raw(),
        })
    }
    
    pub fn as_ptr(&amp;self) -&gt; *const c_char {
        self.ptr
    }
}

impl Drop for FfiString {
    fn drop(&amp;mut self) {
        unsafe {
            let _ = CString::from_raw(self.ptr);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<h3 id="exercise-241-safe-ffi-wrapper"><a class="header" href="#exercise-241-safe-ffi-wrapper">Exercise 24.1: Safe FFI Wrapper</a></h3>
<p>Create a safe Rust wrapper for this C API:</p>
<pre><code class="language-c">typedef struct Buffer {
    char* data;
    size_t size;
} Buffer;

Buffer* buffer_create(size_t size);
void buffer_destroy(Buffer* buf);
int buffer_write(Buffer* buf, const char* data, size_t len);
</code></pre>
<h3 id="exercise-242-custom-allocator"><a class="header" href="#exercise-242-custom-allocator">Exercise 24.2: Custom Allocator</a></h3>
<p>Implement a simple bump allocator using unsafe code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct BumpAllocator {
    start: *mut u8,
    current: *mut u8,
    end: *mut u8,
}

impl BumpAllocator {
    unsafe fn alloc(&amp;mut self, size: usize) -&gt; *mut u8 {
        // TODO: Implement
        todo!()
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="exercise-243-bindgen-integration"><a class="header" href="#exercise-243-bindgen-integration">Exercise 24.3: Bindgen Integration</a></h3>
<p>Use bindgen to create bindings for a simple C library and wrap them in a safe API.</p>
<h2 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways</a></h2>
<p>✅ <strong>Unsafe is sometimes necessary</strong> - For FFI, performance, and low-level code</p>
<p>✅ <strong>Raw pointers need careful handling</strong> - Check null, ensure validity</p>
<p>✅ <strong>FFI requires extern blocks</strong> - And often repr(C) for structs</p>
<p>✅ <strong>Bindgen automates binding generation</strong> - But still need safe wrappers</p>
<p>✅ <strong>Document safety contracts</strong> - Make invariants explicit</p>
<p>✅ <strong>Minimize unsafe scope</strong> - Wrap in safe abstractions</p>
<hr />
<p>Next: <a href="./26_performance.html">Chapter 26: Performance &amp; Optimization</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../transfer/24_workflow.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../transfer/26_performance.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../transfer/24_workflow.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../transfer/26_performance.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
