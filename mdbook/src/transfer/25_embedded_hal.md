# Chapter 25: Embedded HAL - Registers, SVD2Rust & Volatile Access

## Learning Objectives
- Understand memory-mapped registers
- Use volatile access for hardware interaction
- Generate register access with svd2rust
- Apply embedded-hal traits for portability

## Memory-Mapped Registers

Embedded systems control hardware through memory-mapped I/O (MMIO). Hardware registers appear as memory addresses.

### Basic Register Access

```rust
// Raw register access (unsafe)
const GPIO_BASE: usize = 0x4000_1000;
const GPIO_OUTPUT: *mut u32 = (GPIO_BASE + 0x04) as *mut u32;
const GPIO_INPUT: *const u32 = (GPIO_BASE + 0x08) as *const u32;

unsafe fn set_pin_high(pin: u8) {
    let current = std::ptr::read_volatile(GPIO_OUTPUT);
    std::ptr::write_volatile(GPIO_OUTPUT, current | (1 << pin));
}

unsafe fn read_pin(pin: u8) -> bool {
    let value = std::ptr::read_volatile(GPIO_INPUT);
    (value & (1 << pin)) != 0
}
```

## Volatile Access

### Why Volatile?

Hardware registers can change without the compiler's knowledge. Volatile prevents optimization.

```rust
// WITHOUT volatile - compiler might optimize away reads
fn bad_polling() {
    let status_reg = 0x4000_2000 as *const u32;

    // Compiler might optimize this to infinite loop
    while unsafe { *status_reg } & 0x01 == 0 {
        // Wait for ready bit
    }
}

// WITH volatile - compiler preserves every access
fn good_polling() {
    let status_reg = 0x4000_2000 as *const u32;

    while unsafe { std::ptr::read_volatile(status_reg) } & 0x01 == 0 {
        // Correctly polls hardware
    }
}
```

### VolatileCell

Rust provides `VolatileCell` for safe volatile access patterns:

```rust
use core::cell::UnsafeCell;
use core::ptr;

struct VolatileCell<T> {
    value: UnsafeCell<T>,
}

impl<T> VolatileCell<T> {
    pub const fn new(value: T) -> Self {
        VolatileCell {
            value: UnsafeCell::new(value),
        }
    }

    pub fn get(&self) -> T
    where
        T: Copy,
    {
        unsafe { ptr::read_volatile(self.value.get()) }
    }

    pub fn set(&self, value: T) {
        unsafe { ptr::write_volatile(self.value.get(), value) }
    }
}

// Usage
struct GpioRegisters {
    output: VolatileCell<u32>,
    input: VolatileCell<u32>,
    direction: VolatileCell<u32>,
}

static GPIO: *const GpioRegisters = 0x4000_1000 as *const GpioRegisters;

fn set_pin_output(pin: u8) {
    unsafe {
        let direction = (*GPIO).direction.get();
        (*GPIO).direction.set(direction | (1 << pin));
    }
}
```

## SVD2Rust - From Silicon to Safe Code

SVD (System View Description) files describe microcontroller peripherals. `svd2rust` generates Rust code from these descriptions.

### What is SVD?

SVD files are XML descriptions of microcontroller registers:

```xml
<!-- Simplified SVD excerpt -->
<peripheral>
  <name>GPIO</name>
  <baseAddress>0x40001000</baseAddress>
  <registers>
    <register>
      <name>OUTPUT</name>
      <addressOffset>0x004</addressOffset>
      <access>read-write</access>
      <fields>
        <field>
          <name>PIN0</name>
          <bitOffset>0</bitOffset>
          <bitWidth>1</bitWidth>
        </field>
      </fields>
    </register>
  </registers>
</peripheral>
```

### Using svd2rust

```bash
# Install svd2rust
cargo install svd2rust

# Generate Rust code from SVD file
svd2rust -i STM32F103.svd

# This generates lib.rs with register definitions
```

### Generated Code Structure

```rust
// Generated by svd2rust
pub struct Peripherals {
    pub GPIO: GPIO,
    pub USART1: USART1,
    // ... other peripherals
}

pub struct GPIO {
    _marker: PhantomData<*const ()>,
}

impl GPIO {
    pub fn ptr() -> *const gpio::RegisterBlock {
        0x4000_1000 as *const _
    }
}

pub mod gpio {
    pub struct RegisterBlock {
        pub output: OUTPUT,
        pub input: INPUT,
        pub direction: DIRECTION,
    }

    pub struct OUTPUT {
        register: VolatileCell<u32>,
    }

    impl OUTPUT {
        pub fn read(&self) -> u32 {
            self.register.get()
        }

        pub fn write<F>(&self, f: F)
        where
            F: FnOnce(&mut W) -> &mut W,
        {
            let mut w = W { bits: 0 };
            f(&mut w);
            self.register.set(w.bits);
        }

        pub fn modify<F>(&self, f: F)
        where
            F: FnOnce(&R, &mut W) -> &mut W,
        {
            let r = R { bits: self.read() };
            let mut w = W { bits: r.bits };
            f(&r, &mut w);
            self.register.set(w.bits);
        }
    }
}
```

### Using Generated PAC (Peripheral Access Crate)

```rust
use stm32f1xx_pac as pac;

fn setup_gpio() {
    let peripherals = pac::Peripherals::take().unwrap();
    let gpio = &peripherals.GPIOA;

    // Set pin 5 as output
    gpio.crl.modify(|_, w| w.mode5().output().cnf5().push_pull());

    // Set pin 5 high
    gpio.bsrr.write(|w| w.bs5().set_bit());

    // Read pin 0
    let pin_state = gpio.idr.read().idr0().bit_is_set();
}
```

### Field-Level Access

```rust
// Type-safe field manipulation
gpio.output.modify(|r, w| {
    w.pin0().set_bit()     // Set pin 0
     .pin1().clear_bit()   // Clear pin 1
     .pin2().bit(true)     // Set pin 2 to true
     .pin3().bit(pin_state) // Set pin 3 to variable
});

// Read specific fields
let pin_states = gpio.input.read();
if pin_states.pin0().bit_is_set() {
    // Pin 0 is high
}
```

## Embedded HAL Traits

The `embedded-hal` crate provides standard traits for hardware abstraction.

### Digital I/O Traits

```rust
use embedded_hal::digital::{InputPin, OutputPin};

// GPIO pin implementing embedded-hal traits
pub struct Pin<const N: usize> {
    _phantom: PhantomData<()>,
}

impl<const N: usize> OutputPin for Pin<N> {
    type Error = ();

    fn set_low(&mut self) -> Result<(), Self::Error> {
        unsafe {
            let gpio = &*pac::GPIOA::ptr();
            gpio.bsrr.write(|w| w.bits(1 << (N + 16))); // Reset bit
        }
        Ok(())
    }

    fn set_high(&mut self) -> Result<(), Self::Error> {
        unsafe {
            let gpio = &*pac::GPIOA::ptr();
            gpio.bsrr.write(|w| w.bits(1 << N)); // Set bit
        }
        Ok(())
    }
}

impl<const N: usize> InputPin for Pin<N> {
    type Error = ();

    fn is_high(&mut self) -> Result<bool, Self::Error> {
        unsafe {
            let gpio = &*pac::GPIOA::ptr();
            let bits = gpio.idr.read().bits();
            Ok((bits & (1 << N)) != 0)
        }
    }

    fn is_low(&mut self) -> Result<bool, Self::Error> {
        self.is_high().map(|high| !high)
    }
}
```

### SPI Trait Implementation

```rust
use embedded_hal::spi::{Mode, Phase, Polarity};

pub struct Spi {
    spi: pac::SPI1,
}

impl embedded_hal::spi::SpiBus<u8> for Spi {
    type Error = SpiError;

    fn read(&mut self, words: &mut [u8]) -> Result<(), Self::Error> {
        for word in words {
            // Wait for RX buffer to be ready
            while self.spi.sr.read().rxne().bit_is_clear() {}
            *word = self.spi.dr.read().bits() as u8;
        }
        Ok(())
    }

    fn write(&mut self, words: &[u8]) -> Result<(), Self::Error> {
        for word in words {
            // Wait for TX buffer to be empty
            while self.spi.sr.read().txe().bit_is_clear() {}
            self.spi.dr.write(|w| w.bits(*word as u32));
        }
        Ok(())
    }

    fn transfer(&mut self, read: &mut [u8], write: &[u8]) -> Result<(), Self::Error> {
        for (read_byte, write_byte) in read.iter_mut().zip(write.iter()) {
            while self.spi.sr.read().txe().bit_is_clear() {}
            self.spi.dr.write(|w| w.bits(*write_byte as u32));

            while self.spi.sr.read().rxne().bit_is_clear() {}
            *read_byte = self.spi.dr.read().bits() as u8;
        }
        Ok(())
    }
}
```

## Register Patterns

### Bitfield Manipulation

```rust
// Manual bitfield operations
const USART_CR1_UE: u32 = 1 << 13;    // USART Enable
const USART_CR1_RE: u32 = 1 << 2;     // Receiver Enable
const USART_CR1_TE: u32 = 1 << 3;     // Transmitter Enable

// Enable USART with receiver and transmitter
unsafe {
    let usart = &*pac::USART1::ptr();
    usart.cr1.modify(|r, w| {
        w.bits(r.bits() | USART_CR1_UE | USART_CR1_RE | USART_CR1_TE)
    });
}

// Using generated field methods (preferred)
usart.cr1.modify(|_, w| {
    w.ue().enabled()
     .re().enabled()
     .te().enabled()
});
```

### Register Arrays

```rust
// Working with register arrays (e.g., timer capture/compare registers)
pub struct Timer {
    timer: pac::TIM1,
}

impl Timer {
    pub fn set_compare_value(&mut self, channel: usize, value: u16) {
        match channel {
            0 => self.timer.ccr1.write(|w| w.ccr().bits(value)),
            1 => self.timer.ccr2.write(|w| w.ccr().bits(value)),
            2 => self.timer.ccr3.write(|w| w.ccr().bits(value)),
            3 => self.timer.ccr4.write(|w| w.ccr().bits(value)),
            _ => panic!("Invalid channel"),
        }
    }

    pub fn get_compare_value(&self, channel: usize) -> u16 {
        match channel {
            0 => self.timer.ccr1.read().ccr().bits(),
            1 => self.timer.ccr2.read().ccr().bits(),
            2 => self.timer.ccr3.read().ccr().bits(),
            3 => self.timer.ccr4.read().ccr().bits(),
            _ => panic!("Invalid channel"),
        }
    }
}
```

## Practical Example: LED Driver

```rust
use embedded_hal::digital::OutputPin;

pub struct LedDriver<P: OutputPin> {
    pin: P,
    state: bool,
}

impl<P: OutputPin> LedDriver<P> {
    pub fn new(pin: P) -> Self {
        LedDriver { pin, state: false }
    }

    pub fn on(&mut self) -> Result<(), P::Error> {
        self.pin.set_high()?;
        self.state = true;
        Ok(())
    }

    pub fn off(&mut self) -> Result<(), P::Error> {
        self.pin.set_low()?;
        self.state = false;
        Ok(())
    }

    pub fn toggle(&mut self) -> Result<(), P::Error> {
        if self.state {
            self.off()
        } else {
            self.on()
        }
    }

    pub fn is_on(&self) -> bool {
        self.state
    }
}

// Usage with any embedded-hal compatible pin
fn main() {
    let pin = Pin::<5>::new(); // Pin 5
    let mut led = LedDriver::new(pin);

    led.on().unwrap();
    delay_ms(1000);
    led.off().unwrap();
}
```

## Workflow: From SVD to Application

1. **Get SVD file** - From chip vendor or community
2. **Generate PAC** - Run svd2rust
3. **Create HAL** - Implement embedded-hal traits
4. **Write drivers** - Build on embedded-hal
5. **Application** - Use portable drivers

```bash
# 1. Generate PAC from SVD
svd2rust -i chip.svd
cargo install form
form -i lib.rs -o src/

# 2. In Cargo.toml
[dependencies]
embedded-hal = "1.0"
cortex-m = "0.7"

# 3. Create HAL implementation
# 4. Write application using HAL
```

## Memory Safety in Register Access

### RAII Patterns

```rust
pub struct ConfiguredPin<const N: usize> {
    _phantom: PhantomData<()>,
}

impl<const N: usize> ConfiguredPin<N> {
    pub fn into_output(self) -> OutputPin<N> {
        unsafe {
            // Configure pin as output
            let gpio = &*pac::GPIOA::ptr();
            gpio.moder.modify(|r, w| {
                let mask = 0b11 << (N * 2);
                let bits = (r.bits() & !mask) | (0b01 << (N * 2)); // Output mode
                w.bits(bits)
            });
        }
        OutputPin { _phantom: PhantomData }
    }

    pub fn into_input(self) -> InputPin<N> {
        unsafe {
            let gpio = &*pac::GPIOA::ptr();
            gpio.moder.modify(|r, w| {
                let mask = 0b11 << (N * 2);
                let bits = r.bits() & !mask; // Input mode (00)
                w.bits(bits)
            });
        }
        InputPin { _phantom: PhantomData }
    }
}

// Type-safe usage
let pin = ConfiguredPin::<5>::new();
let output_pin = pin.into_output(); // Can't accidentally use as input
```

## Best Practices

- **Use PACs** - Generated register access is safer than manual
- **Volatile everywhere** - For hardware register access
- **Type-safe configuration** - Prevent runtime errors
- **Document register maps** - Include addresses and bit meanings
- **Test on hardware** - Simulators don't catch all issues
- **Follow chip errata** - Hardware has bugs too

---

Next: [Chapter 26: Memory Management & Serialization Paradigm Shift](./26_memory_paradigm.md)